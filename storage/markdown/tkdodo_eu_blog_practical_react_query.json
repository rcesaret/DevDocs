{
  "content": "# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[**GenAI apps + MongoDB Atlas** You don't need a separate database to start\nbuilding GenAI-powered\napps.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8270/0194f710-1b51-7363-9dd3-a9e709d626d3/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#skip-nav\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with MongoDB Atlas, the leading developer data\nplatform](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8268/0194f710-3b94-7520-bac0-9e437e68a3ac/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Hi üëã, I'm Dominik from Vienna üá¶üáπ\nURL: https://tkdodo.eu/blog\n\n#  Hi üëã, I'm Dominik from Vienna üá¶üáπ\n\nI'm a Web Developer and open source maintainer who ‚ù§Ô∏è ReactJs and TypeScript.\nI'm currently maintaining and .\n\nWelcome to my personal blog üìö, where I write about all things React, TypeScript\nand of course the . If you enjoy my blog posts or want to support my open source\nwork, you can [üéó sponsor me on Github\nüéó](https://tkdodo.eu/<https:/github.com/sponsors/TkDodo>)\n\n[React Query - The Bad Parts](https://tkdodo.eu/</blog/react-query-the-bad-\nparts>)\n\n[Ref Callbacks, React 19 and the Compiler](https://tkdodo.eu/</blog/ref-\ncallbacks-react-19-and-the-compiler>)\n\n[My Slow Retreat from Twitter](https://tkdodo.eu/</blog/my-slow-retreat-from-\ntwitter>)\n\n[React Query API Design - Lessons Learned](https://tkdodo.eu/</blog/react-query-\napi-design-lessons-learned>)\n\n[Component Composition is great btw](https://tkdodo.eu/</blog/component-\ncomposition-is-great-btw>)\n\n---\n\n# [React Query - The Bad Parts](https://tkdodo.eu/blog/</blog/react-query-the-bad-\nURL: https://tkdodo.eu/blog/all\n\n[React Query - The Bad Parts](https://tkdodo.eu/blog/</blog/react-query-the-bad-\nparts>)\n\n[Ref Callbacks, React 19 and the Compiler](https://tkdodo.eu/blog/</blog/ref-\ncallbacks-react-19-and-the-compiler>)\n\n[My Slow Retreat from Twitter](https://tkdodo.eu/blog/</blog/my-slow-retreat-\nfrom-twitter>)\n\n[React Query API Design - Lessons Learned](https://tkdodo.eu/blog/</blog/react-\nquery-api-design-lessons-learned>)\n\n[Component Composition is great btw](https://tkdodo.eu/blog/</blog/component-\ncomposition-is-great-btw>)\n\n[Please Stop Using Barrel Files](https://tkdodo.eu/blog/</blog/please-stop-\nusing-barrel-files>)\n\n[React 19 and Suspense - A Drama in 3\nActs](https://tkdodo.eu/blog/</blog/react-19-and-suspense-a-drama-in-3-acts>)\n\n[Automatic Query Invalidation after\nMutations](https://tkdodo.eu/blog/</blog/automatic-query-invalidation-after-\nmutations>)\n\n[Avoiding Hydration Mismatches with\nuseSyncExternalStore](https://tkdodo.eu/blog/</blog/avoiding-hydration-\nmismatches-with-use-sync-external-store>)\n\n[The Uphill Battle of Memoization](https://tkdodo.eu/blog/</blog/the-uphill-\nbattle-of-memoization>)\n\n[React Query and React Context](https://tkdodo.eu/blog/</blog/react-query-and-\nreact-context>)\n\n[You Might Not Need React Query](https://tkdodo.eu/blog/</blog/you-might-not-\nneed-react-query>)\n\n[Breaking React Query's API on purpose](https://tkdodo.eu/blog/</blog/breaking-\nreact-querys-api-on-purpose>)\n\n[Refs, Events and Escape Hatches](https://tkdodo.eu/blog/</blog/refs-events-and-\nescape-hatches>)\n\n[React Query meets React Router](https://tkdodo.eu/blog/</blog/react-query-\nmeets-react-router>)\n\n[Avoiding useEffect with callback refs](https://tkdodo.eu/blog/</blog/avoiding-\nuse-effect-with-callback-refs>)\n\n[Hooks, Dependencies and Stale Closures](https://tkdodo.eu/blog/</blog/hooks-\ndependencies-and-stale-closures>)\n\n[Leveraging the Query Function\nContext](https://tkdodo.eu/blog/</blog/leveraging-the-query-function-context>)\n\n[Mastering Mutations in React Query](https://tkdodo.eu/blog/</blog/mastering-\nmutations-in-react-query>)\n\n[React Query as a State Manager](https://tkdodo.eu/blog/</blog/react-query-as-a-\nstate-manager>)\n\n[Placeholder and Initial Data in React\nQuery](https://tkdodo.eu/blog/</blog/placeholder-and-initial-data-in-react-\nquery>)\n\n[Using WebSockets with React Query](https://tkdodo.eu/blog/</blog/using-web-\nsockets-with-react-query>)\n\n[How can I ... ?](https://tkdodo.eu/blog/</blog/how-can-i>)\n\n[Status Checks in React Query](https://tkdodo.eu/blog/</blog/status-checks-in-\nreact-query>)\n\n[No love for boolean parameters](https://tkdodo.eu/blog/</blog/no-love-for-\nboolean-parameters>)\n\n[Things to know about useState](https://tkdodo.eu/blog/</blog/things-to-know-\nabout-use-state>)\n\n[Flow to TypeScript migration journey](https://tkdodo.eu/blog/</blog/flow-to-\ntype-script-migration-journey>)\n\n[The power of const assertions](https://tkdodo.eu/blog/</blog/the-power-of-\nconst-assertions>)\n\n[Pedantic index signatures in TypeScript\n4.1](https://tkdodo.eu/blog/</blog/pedantic-index-signatures-in-type-\nscript-4-1>)\n\n[Why I don't like reduce](https://tkdodo.eu/blog/</blog/why-i-dont-like-reduce>)\n\n---\n\n# [üéó Sponsor me on Github\nURL: https://tkdodo.eu/blog/sponsors\n\n### [üéó Sponsor me on Github\nüéó](https://tkdodo.eu/blog/<https:/github.com/sponsors/TkDodo>)\n\n---\n\n# [React Query - The Bad Parts](https://tkdodo.eu/blog/tags/</blog/react-query-\nURL: https://tkdodo.eu/blog/tags/react-js\n\n[React Query - The Bad Parts](https://tkdodo.eu/blog/tags/</blog/react-query-\nthe-bad-parts>)\n\n[Ref Callbacks, React 19 and the\nCompiler](https://tkdodo.eu/blog/tags/</blog/ref-callbacks-react-19-and-the-\ncompiler>)\n\n[React Query API Design - Lessons\nLearned](https://tkdodo.eu/blog/tags/</blog/react-query-api-design-lessons-\nlearned>)\n\n[React 19 and Suspense - A Drama in 3\nActs](https://tkdodo.eu/blog/tags/</blog/react-19-and-suspense-a-drama-\nin-3-acts>)\n\n[Automatic Query Invalidation after\nMutations](https://tkdodo.eu/blog/tags/</blog/automatic-query-invalidation-\nafter-mutations>)\n\n[Avoiding Hydration Mismatches with\nuseSyncExternalStore](https://tkdodo.eu/blog/tags/</blog/avoiding-hydration-\nmismatches-with-use-sync-external-store>)\n\n[React Query and React Context](https://tkdodo.eu/blog/tags/</blog/react-query-\nand-react-context>)\n\n[You Might Not Need React Query](https://tkdodo.eu/blog/tags/</blog/you-might-\nnot-need-react-query>)\n\n[Breaking React Query's API on\npurpose](https://tkdodo.eu/blog/tags/</blog/breaking-react-querys-api-on-\npurpose>)\n\n[Refs, Events and Escape Hatches](https://tkdodo.eu/blog/tags/</blog/refs-\nevents-and-escape-hatches>)\n\n[React Query meets React Router](https://tkdodo.eu/blog/tags/</blog/react-query-\nmeets-react-router>)\n\n[Avoiding useEffect with callback\nrefs](https://tkdodo.eu/blog/tags/</blog/avoiding-use-effect-with-callback-\nrefs>)\n\n[Hooks, Dependencies and Stale\nClosures](https://tkdodo.eu/blog/tags/</blog/hooks-dependencies-and-stale-\nclosures>)\n\n[Leveraging the Query Function\nContext](https://tkdodo.eu/blog/tags/</blog/leveraging-the-query-function-\ncontext>)\n\n[Mastering Mutations in React\nQuery](https://tkdodo.eu/blog/tags/</blog/mastering-mutations-in-react-query>)\n\n[React Query as a State Manager](https://tkdodo.eu/blog/tags/</blog/react-query-\nas-a-state-manager>)\n\n[Placeholder and Initial Data in React\nQuery](https://tkdodo.eu/blog/tags/</blog/placeholder-and-initial-data-in-react-\nquery>)\n\n[Using WebSockets with React Query](https://tkdodo.eu/blog/tags/</blog/using-\nweb-sockets-with-react-query>)\n\n[No love for boolean parameters](https://tkdodo.eu/blog/tags/</blog/no-love-for-\nboolean-parameters>)\n\n[Flow to TypeScript migration journey](https://tkdodo.eu/blog/tags/</blog/flow-\nto-type-script-migration-journey>)\n\n---\n\n# [React Query - The Bad Parts](https://tkdodo.eu/blog/tags/</blog/react-query-\nURL: https://tkdodo.eu/blog/tags/react-query\n\n[React Query - The Bad Parts](https://tkdodo.eu/blog/tags/</blog/react-query-\nthe-bad-parts>)\n\n[React Query API Design - Lessons\nLearned](https://tkdodo.eu/blog/tags/</blog/react-query-api-design-lessons-\nlearned>)\n\n[React 19 and Suspense - A Drama in 3\nActs](https://tkdodo.eu/blog/tags/</blog/react-19-and-suspense-a-drama-\nin-3-acts>)\n\n[Automatic Query Invalidation after\nMutations](https://tkdodo.eu/blog/tags/</blog/automatic-query-invalidation-\nafter-mutations>)\n\n[React Query and React Context](https://tkdodo.eu/blog/tags/</blog/react-query-\nand-react-context>)\n\n[You Might Not Need React Query](https://tkdodo.eu/blog/tags/</blog/you-might-\nnot-need-react-query>)\n\n[Breaking React Query's API on\npurpose](https://tkdodo.eu/blog/tags/</blog/breaking-react-querys-api-on-\npurpose>)\n\n[React Query meets React Router](https://tkdodo.eu/blog/tags/</blog/react-query-\nmeets-react-router>)\n\n[Leveraging the Query Function\nContext](https://tkdodo.eu/blog/tags/</blog/leveraging-the-query-function-\ncontext>)\n\n[Mastering Mutations in React\nQuery](https://tkdodo.eu/blog/tags/</blog/mastering-mutations-in-react-query>)\n\n[React Query as a State Manager](https://tkdodo.eu/blog/tags/</blog/react-query-\nas-a-state-manager>)\n\n[Placeholder and Initial Data in React\nQuery](https://tkdodo.eu/blog/tags/</blog/placeholder-and-initial-data-in-react-\nquery>)\n\n[Using WebSockets with React Query](https://tkdodo.eu/blog/tags/</blog/using-\nweb-sockets-with-react-query>)\n\n[Status Checks in React Query](https://tkdodo.eu/blog/tags/</blog/status-checks-\nin-react-query>)\n\n---\n\n# * **#2: React Query Data Transformations**\nURL: https://tkdodo.eu/blog/react-query-data-transformations\n\n* **#2: React Query Data Transformations**\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[a more flexible and intuitive way to work with\ndata.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8277/0194f710-b528-7123-abc2-80c932b22a35/>)\n\nWelcome to Part 2 of \"Things I have to say about react-query\". As I've become\nmore and more involved with the library and the community around it, I've\nobserved some more patterns people frequently ask about. Initially, I wanted to\nwrite them all down in one big article, but then decided to break them down into\nmore manageable pieces. The first one is about a quite common and important\ntask: Data Transformation.\n\nLet's face it - most of us are using GraphQL. If you do, then you can be very\nhappy because you have the luxury of requesting your data in the format that you\ndesire.\n\nIf you are working with REST though, you are constrained by what the backend\nreturns. So how and where do you best transform data when working with react-\nquery? The only answer worth a damn in software development applies here as\nwell:\n\nHere are 3+1 approaches on where you transform data with their respective pros\nand cons:\n\nThis is my favourite approach, if you can afford it. If the backend returns data\nin exactly the structure we want, there is nothing we need to do. While this\nmight sound unrealistic in many cases, e.g. when working with public REST APIs,\nit is also quite possible to achieve in enterprise applications. If you are in\ncontrol of the backend and have an endpoint that returns data for your exact\nuse-case, prefer to deliver the data the way you expect it.\n\nüü¢ no work on the frontend üî¥ not always possible\n\nThe is the function that you pass to . It expects you to return a Promise, and\nthe resulting data winds up in the query cache. But it doesn't mean that you\nhave to absolutely return data in the structure that the backend delivers here.\nYou can transform it before doing so:\n\n```\n\nCopyqueryFn-transformation: copy code to clipboard\n\n```\n\nOn the frontend, you can then work with this data \"as if it came like this from\nthe backend\". No where in your code will you actually work with todo names that\nare upper-cased. You will also have access to the original structure. If you\nlook at the react-query-devtools, you will see the transformed structure. If you\nlook at the network trace, you'll see the original structure. This might be\nconfusing, so keep that in mind.\n\nAlso, there is no optimization that react-query can do for you here. Every time\na fetch is executed, your transformation will run. If it's expensive, consider\none of the other alternatives. Some companies also have a shared api layer that\nabstracts data fetching, so you might not have access to this layer to do your\ntransformations.\n\nüü¢ very \"close to the backend\" in terms of co-location üü° the transformed\nstructure winds up in the cache, so you don't have access to the original\nstructure üî¥ runs on every fetch üî¥ not feasible if you have a shared api layer\nthat you cannot freely modify\n\n### 2. In the render function\n\nAs advised in , if you create custom hooks, you can easily do transformations\nthere:\n\n```\n\nCopyrender-transformation: copy code to clipboard\n\n```\n\nAs it stands, this will not only run every time your fetch function runs, but\nactually on every render (even those that do not involve data fetching). This is\nlikely not a problem at all, but if it is, you can optimize with . Be careful to\ndefine your dependencies . inside the queryInfo will be referentially stable\nunless something really changed (in which case you want to recompute your\ntransformation), but the itself will . If you add as your dependency, the\ntransformation will again run on every render:\n\n```\n\nCopyuseMemo-dependencies: copy code to clipboard\n\n// üö® don't do this - the useMemo does nothing at all here!\n\n// ‚úÖ correctly memoizes by queryInfo.data\n\n```\n\nEspecially if you have additional logic in your custom hook to combine with your\ndata transformation, this is a good option. Be aware that data can be\npotentially undefined, so use optional chaining when working with it.\n\nüü¢ optimizable via useMemo üü° exact structure cannot be inspected in the devtools\nüî¥ a bit more convoluted syntax üî¥ data can be potentially undefined üî¥ not\nrecommended with tracked queries\n\n### 3. using the select option\n\nv3 introduced built-in selectors, which can also be used to transform data:\n\n```\n\nCopyselect-transformation: copy code to clipboard\n\n```\n\nselectors will only be called if exists, so you don't have to care about here.\nSelectors like the one above will also run on every render, because the\nfunctional identity changes (it's an inline function). If your transformation is\nexpensive, you can memoize it either with useCallback, or by extracting it to a\nstable function reference:\n\n```\n\nCopyselect-memoizations: copy code to clipboard\n\n// ‚úÖ uses a stable function reference\n\n// ‚úÖ memoizes with useCallback\n\n```\n\nFurther, the select option can also be used to subscribe to only parts of the\ndata. This is what makes this approach truly unique. Consider the following\nexample:\n\n```\n\nCopyselect-partial-subscriptions: copy code to clipboard\n\n```\n\nHere, we've created a like API by passing a custom selector to our . The custom\nhooks still works like before, as will be if you don't pass it, so the whole\nstate will be returned.\n\nBut if you pass a selector, you are now only subscribed to the result of the\nselector function. This is quite powerful, because it means that even if we\nupdate the name of a todo, our component that only subscribes to the count via\nwill rerender. The count hasn't changed, so react-query can choose to inform\nthis observer about the update ü•≥ (Please note that this is a bit simplified here\nand technically not entirely true - I will talk in more detail about render\noptimizations in Part 3).\n\nüü¢ best optimizations üü¢ allows for partial subscriptions üü° structure can be\ndifferent for every observer üü° structural sharing is performed twice (I will\nalso talk about this in more detail in )\n\nThat's all I have for today üëã. Feel free to reach out to me on , if you have any\nquestions, or just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/react-query-render-optimizations\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * **#3: React Query Render Optimizations**\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[a more flexible and intuitive way to work with\ndata.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8277/0194f710-c901-7693-b719-6a91bf199b53/>)\n\nI've already written quite a bit about render optimizations when describing the\nselect option in [#2: React Query Data\nTransformations](https://tkdodo.eu/blog/<react-query-data-transformations>).\nHowever, \"Why does React Query re-render my component two times even though\nnothing changed in my data\" is the question I probably needed to answer the most\n(apart from maybe: \"Where can I find the v2 docs\" üòÖ). So let me try to explain\nit in-depth.\n\nI haven't been entirely honest in the when I said that this component will only\nre-render if the length of todos change:\n\n```\n\nCopycount-component: copy code to clipboard\n\n```\n\nEvery time you make a background refetch, this component will re-render twice\nwith the following query info:\n\n```\n\n{ status: 'success', data: 2, isFetching: true }\n\n{ status: 'success', data: 2, isFetching: false }\n\n```\n\nThat is because React Query exposes a lot of meta information for each query,\nand is one of them. This flag will always be true when a request is in-flight.\nThis is quite useful if you want to display a background loading indicator. But\nit's also kinda unnecessary if you don't do that.\n\nFor this use-case, React Query has the option. It can be set on a per-observer\nlevel to tell React Query: Please only inform this observer about changes if one\nof these props change. By setting this option to , we will find the optimized\nversion we seek:\n\n```\n\nCopyoptimized-with-notifyOnChangeProps: copy code to clipboard\n\n```\n\nYou can see this in action in the example in the docs.\n\nWhile the above code works well, it can get out of sync quite easily. What if we\nwant to react to the , too? Or we start to use the flag? We have to keep the\nlist in sync with whichever fields we are actually using in our components. If\nwe forget to do that, and we only observe the property, but get an that we also\ndisplay, our component will not re-render and is thus outdated. This is\nespecially troublesome if we hard-code this in our custom hook, because the hook\ndoes not know what the component will actually use:\n\n```\n\nCopyoutdated-component: copy code to clipboard\n\n// üö® we are using error,\n\n// but we are not getting notified if error changes!\n\n```\n\nAs I have hinted in the disclaimer in the beginning, I think this is way worse\nthan the occasional unneeded re-render. Of course, we can pass the option to the\ncustom hook, but this still feels quite manual and boilerplate-y. Is there a way\nto do this automatically? Turns out, there is:\n\nI'm quite proud of this feature, given that it was my first major contribution\nto the library. If you set to , React Query will keep track of the fields you\nare using during render, and will use this to compute the list. This will\noptimize exactly the same way as specifying the list manually, except that you\ndon't have to think about it. You can also turn this on globally for all your\nqueries:\n\n```\n\nCopytracked-queries: copy code to clipboard\n\n```\n\nWith this, you never have to think about re-renders again. Of course, tracking\nthe usages has a bit of an overhead as well, so make sure you use this wisely.\nThere are also some limitations to tracked queries, which is why this is an opt-\nin feature:\n\n  * If you use , you are effectively observing all fields. Normal destructuring is fine, just don't do this:\n\n```\n\nCopyproblematic-rest-destructuring: copy code to clipboard\n\n// üö® will track all fields\n\n// ‚úÖ this is totally fine\n\n```\n\n  * Tracked queries only work \"during render\". If you only access fields during effects, they will not be tracked. This is quite the edge case though because of dependency arrays:\n\n```\n\nCopytracking-effects: copy code to clipboard\n\n// üö® will not corectly track data\n\n// ‚úÖ fine because the dependency array is accessed during render\n\n```\n\n  * Tracked queries don't reset on each render, so if you track a field once, you'll track it for the lifetime of the observer:\n\n```\n\nCopyno-reset: copy code to clipboard\n\n// üü° we will track the data field if someCondition was true in any previous\nrender cycle\n\n```\n\nA different, but no less important render optimization that React Query has\nturned on out of the box is . This feature makes sure that we keep referential\nidentity of our on every level. As an example, suppose you have the following\ndata structure:\n\n```\n\n```\n\nNow suppose we transition our first todo into the state, and we make a\nbackground refetch. We'll get a completely new json from our backend:\n\n```\n\n { \"id\": 1, \"name\": \"Learn React\", \"status\": \"active\" },\n\n { \"id\": 1, \"name\": \"Learn React\", \"status\": \"done\" },\n\n { \"id\": 2, \"name\": \"Learn React Query\", \"status\": \"todo\" }\n\n```\n\nNow React Query will attempt to compare the old state and the new and keep as\nmuch of the previous state as possible. In our example, the todos array will be\nnew, because we updated a todo. The object with id 1 will also be new, but the\nobject for id 2 will be the same reference as the one in the previous state -\nReact Query will just copy it over to the new result because nothing has changed\nin it.\n\nThis comes in very handy when using selectors for partial subscriptions:\n\n```\n\nCopyoptimized-selectors: copy code to clipboard\n\n// ‚úÖ will only re-render if _something_ within todo with id:2 changes\n\n// thanks to structural sharing\n\n```\n\nAs I've hinted before, for selectors, structural sharing will be done twice:\nOnce on the result returned from the to determine if anything changed at all,\nand then once more on the of the selector function. In some instances,\nespecially when having very large datasets, structural sharing be a bottleneck.\nIt also only works on json-serializable data. If you don't need this\noptimization, you can turn it off by setting on any query.\n\nHave a look at the if you want to learn more about what happens under the hood.\n\nPhew, this was quite a handful. Feel free to reach out to me on if you have any\nquestions, or just leave a comment below. ‚¨áÔ∏è I'm always happy to help!\n\nLike the monospace font in the code blocks?\n\n---\n\n# Status Checks in React Query\nURL: https://tkdodo.eu/blog/status-checks-in-react-query\n\n# Status Checks in React Query\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * **#4: Status Checks in React Query**\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Find out how Algolia AI Search can instantly and precisely understand your\nuser's\nintent.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8293/0194f710-dc29-7fb3-a46b-1ff8ca6ecf37/>)\n\nOne advantage of React Query is the easy access to status fields of the query.\nYou instantly know if your query is loading or if it's erroneous. For this, the\nlibrary exposes a bunch of boolean flags, which are mostly derived from the\ninternal state machine. Looking at , your query can be in one of the following\nstates:\n\n  * : Your query was successful, and you have for it\n  * : Your query did not work, and an is set\n  * : Your query has no data\n\nNote that the flag is part of the internal state machine - it is an additional\nflag that will be true whenever a request is in-flight. You can be fetching and\nsuccess, you can be fetching and error - but you cannot be loading and success\nat the same time. The state machine makes sure of that.\n\nMost examples look something like this:\n\n```\n\nCopystandard-example: copy code to clipboard\n\n'An error has occurred: '\n\n```\n\nHere, we check for pending and error first, and then display our data. This is\nprobably fine for some use-cases, but not for others. Many data fetching\nsolutions, especially hand-crafted ones, have no refetch mechanism, or only\nrefetch on explicit user interactions.\n\nIt refetches quite aggressively per default, and does so without the user\nactively requesting a refetch. The concepts of , and are great for keeping your\ndata accurate, but they might cause a confusing ux if such an automatic\nbackground refetch fails.\n\nIn many situations, if a background refetch fails, it could be silently ignored.\nBut the code above does not do that. Let's look at two examples:\n\n  * The user opens a page, and the initial query loads successfully. They are working on the page for some time, then switch browser tabs to check emails. They come back some minutes later, and React Query will do a background refetch. Now that fetch fails.\n  * Our user is on page with a list view, and they click on one item to drill down to the detail view. This works fine, so they go back to the list view. Once they go to the detail view again, they will see data from the cache. This is great - except if the background refetch fails.\n\nIn both situations, our query will be in the following state:\n\n```\n\n```\n\nAs you can see, we will have an error the stale data available. This is what\nmakes React Query great - it embraces the stale-while-revalidate caching\nmechanism, which means it will always give you data if it exists, even if it's\nstale.\n\nNow it's up to us to decide what we display. Is it important to show the error?\nIs it enough to show the stale data only, if we have any? Should we show both,\nmaybe with a little indicator?\n\nThere is no clear answer to this question - it depends on your exact use-case.\nHowever, given the two above examples, I think it would be a somewhat confusing\nuser experience if data would be replaced with an error screen.\n\nThis is even more relevant when we take into account that React Query will retry\nfailed queries three times per default with exponential backoff, so it might\ntake a couple of seconds until the stale data is replaced with the error screen.\nIf you also have no background fetching indicator, this can be really\nperplexing.\n\nThis is why I usually check for data-availability first:\n\n```\n\nCopydata-first: copy code to clipboard\n\n'An error has occurred: '\n\n```\n\nAgain, there is no clear principle of what is right, as it is highly dependent\non the use-case. Everyone should be aware of the consequences that aggressive\nrefetching has, and we have to structure our code accordingly rather than\nstrictly following the simple todo-examples üòâ.\n\nSpecial thanks go to who first highlighted to me why this pattern of status\nchecking can be harmful in some situations.\n\nFeel free to reach out to me on if you have any questions, or just leave a\ncomment below ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Photo by\nURL: https://tkdodo.eu/blog/testing-react-query\n\nPhoto by\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[video to see firsthand how to upgrade your site with end-to-end AI\nSearch.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8294/0194f710-ed5c-7753-ab48-bcf783b26528/>)\n\nQuestions around the testing topic come up quite often together with React\nQuery, so I'll try to answer some of them here. I think one reason for that is\nthat testing \"smart\" components (also called ) is not the easiest thing to do.\nWith the rise of hooks, this split has been largely deprecated. It is now\nencouraged to consume hooks directly where you need them rather than doing a\nmostly arbitrary split and drill props down.\n\nI think this is generally a very good improvement for colocation and code\nreadability, but we now have more components that consume dependencies outside\nof \"just props\".\n\nThey might . They might . Or they might .\n\nThose components are technically no longer pure, because calling them in\ndifferent environments leads to different results. When testing them, you need\nto carefully setup those surrounding environments to get things working.\n\nSince React Query is an async server state management library, your components\nwill likely make requests to a backend. When testing, this backend is not\navailable to actually deliver data, and even if, you likely don't want to make\nyour tests dependent on that.\n\nThere are tons of articles out there on how to mock data with jest. You can mock\nyour api client if you have one. You can mock fetch or axios directly. I can\nonly second what Kent C. Dodds has written in his article :\n\nIt can be your single source of truth when it comes to mocking your apis:\n\n  * works in node for testing\n  * has a so you can write stories for your components that \n  * works in the browser for development purposes, and you'll still see the requests going out in the browser devtools\n  * works with cypress, similar to fixtures\n\nWith our network layer being taken care of, we can start talking about React\nQuery specific things to keep an eye on:\n\nWhenever you use React Query, you need a QueryClientProvider and give it a\nqueryClient - a vessel which holds the . The cache will in turn hold the data of\nyour queries.\n\nI prefer to give each test its own QueryClientProvider and create a for each\ntest. That way, tests are completely isolated from each other. A different\napproach might be to clear the cache after each test, but I like to keep shared\nstate between tests as minimal as possible. Otherwise, you might get unexpected\nand flaky results if you run your tests in parallel.\n\nIf you are testing custom hooks, I'm quite certain you're using . It's the\neasiest thing there is to test hooks. With that library, we can wrap our hook in\na , which is a React component to wrap the test component in when rendering. I\nthink this is the perfect place to create the QueryClient, because it will be\nexecuted once per test:\n\n```\n\nCopywrapper: copy code to clipboard\n\n// ‚úÖ creates a new QueryClient for each test\n\n```\n\nIf you want to test a Component that uses a hook, you also need to wrap that\nComponent in QueryClientProvider. A small wrapper around from seems like a good\nchoice. Have a look at how React Query does it .\n\nIt's one of the most common \"gotchas\" with React Query and testing: The library\ndefaults to three retries with exponential backoff, which means that your tests\nare likely to timeout if you want to test an erroneous query. The easiest way to\nturn retries off is, again, via the . Let's extend the above example:\n\n```\n\nCopyno-retries: copy code to clipboard\n\n// ‚úÖ turns retries off\n\n```\n\nThis will set the defaults for all queries in the component tree to \"no\nretries\". It is important to know that this will only work if your actual has no\nexplicit retries set. If you have a query that wants 5 retries, this will still\ntake precedence, because defaults are only taken as a fallback.\n\nThe best advice I can give you for this problem is: Don't set these options on\ndirectly. Try to use and override the defaults as much as possible, and if you\nreally need to change something for specific queries, use .\n\nSo for example, instead of setting retry on :\n\n```\n\nCopynot-on-useQuery: copy code to clipboard\n\n// üö® you cannot override this setting for tests!\n\n```\n\n```\n\nCopysetQueryDefaults: copy code to clipboard\n\n// ‚úÖ only todos will retry 5 times\n\n```\n\nHere, all queries will retry two times, only will retry five times, and I still\nhave the option to turn it off for all queries in my tests üôå.\n\nOf course, this only works for known query keys. Sometimes, you really want to\nset some configs on a subset of your component tree. In v2, React Query had a\nfor that exact use-case. You can achieve the same thing in v3 with a couple of\nlines of codes:\n\n```\n\nCopyReactQueryConfigProvider: copy code to clipboard\n\n```\n\nYou can see this in action in this .\n\nSince React Query is async by nature, when running the hook, you won't\nimmediately get a result. It usually will be in loading state and without data\nto check. The from react-hooks-testing-library offer a lot of ways to solve this\nproblem. For the simplest case, we can just wait until the query has\ntransitioned to success state:\n\n```\n\nCopywaitFor: copy code to clipboard\n\n// ‚úÖ wait until the query has transitioned to success state\n\n```\n\nI've set up a quick repository where all of this comes nicely together: mock-\nservice-worker, react-testing-library and the mentioned wrapper. It contains\nfour tests - basic failure and success tests for custom hooks and components.\nHave a look here:\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/react-query-and-type-script\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * **#6: React Query and TypeScript**\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Transform docs into structured data with\nSensible.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8224/0194f711-01e2-7c51-a187-1a419d756dc8/>)\n\nis üî• - this seems to be a common understanding now in the frontend community.\nMany developers expect libraries to either be written in TypeScript, or at least\nprovide good type definitions. For me, if a library is written in TypeScript,\nthe type definitions are the best documentation there is. It's never wrong\nbecause it directly reflects the implementation. I frequently look at type\ndefinitions before I read API docs.\n\nReact Query was initially written in JavaScript (v1), and was then re-written to\nTypeScript with v2. This means that right now, there is very good support for\nTypeScript consumers.\n\nThere are however a couple of \"gotchas\" when working with TypeScript due to how\ndynamic and unopinionated React Query is. Let's go through them one by one to\nmake your experience with it even better.\n\nReact Query heavily uses . This is necessary because the library does not\nactually fetch data for you, and it cannot know what the data will have that\nyour api returns.\n\nThe TypeScript section in the is not very extensive, and it tells us to\nexplicitly specify the Generics that expects when calling it:\n\n```\n\nCopyexplicit-generics: copy code to clipboard\n\n```\n\nOver time, React Query has added more Generics to the hook (there are now four\nof them), mainly because more functionality was added. The above code works, and\nit will make sure that the property of our custom hook is correctly typed to as\nwell as that our will be of type . But it will not work like that for more\nadvanced use-cases, especially when the other two Generics are needed.\n\nThis is the current definition of the hook:\n\n```\n\nCopyuseQuery: copy code to clipboard\n\n```\n\nThere's a lot of stuff going on, so let's try to break it down:\n\n  * : the type returned from the . In the above example, it's .\n  * : the type of Errors to expect from the . in the example.\n  * : the type our property will eventually have. Only relevant if you use the option, because then the property can be different from what the returns. Otherwise, it will default to whatever the returns.\n  * : the type of our , only relevant if you use the that is passed to your .\n\nAs you can also see, all those Generics have default values, which means that if\nyou don't provide them, TypeScript will fall back to those types. This works\npretty much the same as default parameters in JavaScript:\n\n```\n\nCopydefault-parameters: copy code to clipboard\n\n```\n\nTypeScript works best if you let it infer (or figure out) what type something\nshould be on its own. Not only does it make code easier to (because you don't\nhave to type all the types üòÖ), but it will also make it easier to . In many\ninstances, it can make code look exactly like JavaScript. Some simple examples\nof type inference would be:\n\n```\n\nCopytype-inference: copy code to clipboard\n\n// üöÄ both greeting and the result of greet will be string\n\n```\n\nWhen it comes to Generics, they can also generally be inferred from their usage,\nwhich is super awesome. You could also provide them manually, but in many cases,\nyou don't need to.\n\n```\n\nCopygeneric-identity: copy code to clipboard\n\n// üö® no need to provide the generic\n\n// ‚ö†Ô∏è or to annotate the result\n\n// üòé infers correctly to `string`\n\n```\n\n...doesn't exist in TypeScript yet (see this ). This basically means that if you\nprovide Generic, you have to provide of them. But because React Query has\ndefault values for Generics, we might not notice right away that they will be\ntaken. The resulting error messages can be quite cryptic. Let's look at an\nexample where this actually backfires:\n\n```\n\nCopydefault-generics: copy code to clipboard\n\n// üö® Type '(groups: Group[]) => number' is not assignable to type '(data:\nGroup[]) => Group[]'.\n\n// Type 'number' is not assignable to type 'Group[]'.ts(2322)\n\n```\n\nBecause we haven't provided the 3rd Generic, the default value kicks in, which\nis also , but we return from our function. One fix is to simply add the 3rd\nGeneric:\n\n```\n\nCopythird-generic: copy code to clipboard\n\n```\n\nAs long as we don't have Partial Type Argument Inference, we have to work with\nwhat we got.\n\nLet's start by passing in any Generics at all and let TypeScript figure out what\nto do. For this to work, we need the to have a good return type. Of course, if\nyou inline that function without an explicit return type, you will have -\nbecause that's what or give you:\n\n```\n\nCopyinlined-queryFn: copy code to clipboard\n\n// üö® data will be `any` here\n\n```\n\nIf you (like me) like to keep your api layer separated from your queries, you'll\nneed to add type definitions anyways to avoid , so React Query can infer the\nrest:\n\n```\n\nCopyinferred-types: copy code to clipboard\n\n// ‚úÖ data will be `Group[] | undefined` here\n// ‚úÖ data will be `number | undefined` here\n\n```\n\nAdvantages of this approach are:\n\n  * no more manually specifying Generics\n  * works for cases where the 3rd (select) and 4th (QueryKey) Generic are needed\n  * will continue to work if more Generics are added\n  * code is less confusing / looks more like JavaScript\n\nWhat about error, you might ask? Per default, without any Generics, error will\nbe inferred to . This might sound like a bug, why is it not ? But it is actually\non purpose, because in JavaScript, you can throw - it doesn't have to be of type\n:\n\n```\n\nCopytotally-legit-throw-statements: copy code to clipboard\n\n```\n\nSince React Query is not in charge of the function that returns the Promise, it\nalso can't know what type of errors it might produce. So is correct. Once\nTypeScript allows skipping some generics when calling a function with multiple\ngenerics (see [this issue for more\ninformation](https://tkdodo.eu/blog/<https:/github.com/microsoft/TypeScript/issues/10571>)),\nwe could handle this better, but for now, if we need to work with errors and\ndon't want to resort to passing Generics, we can narrow the type with an\ninstanceof check:\n\n```\n\nCopynarrow-with-instanceof: copy code to clipboard\n\n// üö® this doesn't work because: Object is of type 'unknown'.ts(2571)\n\n// ‚úÖ the instanceOf check narrows to type `Error`\n\n```\n\nSince we need to make some kind of check anyways to see if we have an error, the\ninstanceof check doesn't look like a bad idea at all, and it will also make sure\nthat our error actually has a property message at runtime. This is also in line\nwith what TypeScript has planned for the 4.4 release, where they'll introduce a\nnew compiler flag , where catch variables will be instead of (see ).\n\nI rarely use destructuring when working with React Query. First of all, names\nlike and are quite universal (purposefully so), so you'll likely rename them\nanyway. Keeping the whole object will keep the context of what data it is or\nwhere the error is coming from. It will further help TypeScript to narrow types\nwhen using the status field or one of the status booleans, which it cannot do if\nyou use destructuring:\n\n```\n\nCopytype-narrowing: copy code to clipboard\n\n// üö® data will still be `Group[] | undefined` here\n// ‚úÖ groupsQuery.data will now be `Group[]`\n\n```\n\nThis has nothing to do with React Query, it is just how TypeScript works. has a\ngood explanation for this behaviour\n\n[The comment from is exactly right, TypeScript does refinement on the types of\nindividual symbols. Once you split them apart, it can't keep track of the\nrelationship any more. Doing this in general would be computationally hard. It\ncan also be hard for\npeople.](https://tkdodo.eu/blog/<https:/x.com/danvdk/status/1363614288103964672>)\n\n## Type safety with the enabled option\n\nI've expressed my ‚ô•Ô∏è for the right from the start, but it can be a bit tricky on\ntype level if you want to use it for and disable your query for as long as some\nparameters are not yet defined:\n\n```\n\nCopythe-enabled-option: copy code to clipboard\n\n// üö® Argument of type 'number | undefined' is not assignable to parameter of type 'number'.\n// Type 'undefined' is not assignable to type 'number'.ts(2345)\n\n```\n\nTechnically, TypeScript is right, is possibly : the option does not perform any\ntype narrowing. Also, there are ways to bypass the option, for example by\ncalling the method returned from . In that case, the might really be .\n\nI've found the best way to go here, if you don't like the , is to accept that\ncan be and reject the Promise in the . It's a bit of duplication, but it's also\nexplicit and safe:\n\n```\n\nCopyexplicit-id-check: copy code to clipboard\n\n// ‚úÖ check id at runtime because it can be `undefined`\n\n```\n\nGetting optimistic updates right in TypeScript is not an easy feat, so we've\ndecided to add it as a comprehensive to the docs.\n\nThe important part is: You have to explicitly type the argument passed to in\norder to get the best type inference. I don't fully comprehend why that is, but\nit again seems to have something to do with inference of Generics. Have a look\nfor more information.\n\nFor the most parts, typing is no different from typing . One noticeable gotcha\nis that the value, which is passed to the , is typed as . Could be improved in\nthe library for sure, but as long as it's , it's probably best to explicitly\nannotate it:\n\n```\n\nCopyuseInfiniteQuery: copy code to clipboard\n\n// ‚ö†Ô∏è explicitly type pageParam to override `any`\n\n```\n\nIf returns a , will have its type nicely inferred, and we can use the same type\nto annotate .\n\n## Typing the default query function\n\nI am personally not using a , but I know many people are. It's a neat way to\nleverage the passed to directly build your request url. If you inline the\nfunction when creating the , the type of the passed will also be inferred for\nyou. TypeScript is just so much better when you inline stuff :)\n\n```\n\nCopydefaultQueryFn: copy code to clipboard\n\n```\n\nThis just works, however, is inferred to type , because the whole is an . At the\ntime of the creation of the queryClient, there is absolutely no guarantee how\nthe queryKeys will be constructed when calling , so there is only so much React\nQuery can do. That is just the nature of this highly dynamic feature. It's not a\nbad thing though because it means you now have to work defensively and narrow\nthe type with runtime checks to work with it, for example:\n\n```\n\nCopynarrow-with-typeof: copy code to clipboard\n\n// ‚úÖ narrow the type of url to string\n\n// so that we can work with it\n\n```\n\nI think this shows quite well why is such a great (and underused) type compared\nto . It has become my favourite type lately - but that is subject for another\nblog post. üòä\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Using WebSockets with React Query\nURL: https://tkdodo.eu/blog/using-web-sockets-with-react-query\n\n# Using WebSockets with React Query\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * **#7: Using WebSockets with React Query**\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[**GenAI apps + MongoDB Atlas** You don't need a separate database to start\nbuilding GenAI-powered\napps.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8270/0194f711-1b94-7022-a380-d1dbc76f9fd3/>)\n\nHow to handle live data using WebSockets together with React Query has been one\nof the most asked questions lately, so I thought I'd give it a try, play around\nwith it a bit and report my findings. That's what this post is about :)\n\nSimply put, WebSockets allow push messages, or \"live data\", to be sent from the\nserver to the client (browser). Usually with HTTP, the client makes a request to\nthe server, specifying that they would like some data please, the server\nresponds with that data or an error and then the connection closes.\n\nSince the client is the one opening the connections and initiating the requests,\nthat leaves no room for the server to push data to the client when the server\nknows that an update is available.\n\nLike with any other HTTP request, the browser initiates the connection, but\nindicates that they would like to upgrade the connection to a WebSocket. If the\nserver accepts this, they will then switch the protocol. This connection will\nnot terminate, but will stay open until either side decides to close it. Now, we\nhave a fully functioning bi-directional connection open, where both sides can\ntransmit data.\n\nThis has the main advantage that the server can now push selective updates to\nthe client. This can come in very handy if you have multiple users viewing the\nsame data, and one user makes an update. Usually, the other clients will not see\nthat update until they actively refetch. WebSockets allow to instantly push\nthose updates in real-time.\n\nSince React Query is primarily a client side async state management library, I\nwill talk about how to set up WebSockets on the server. I've honestly never done\nit, and it also depends on which technology you are using in the backend.\n\nReact Query doesn't have anything built-in specifically for WebSockets. That\ndoesn't mean that WebSockets are not supported or that they don't work well with\nthe library. It's just that React Query is agnostic when it comes to how you\nfetch your data: All it needs is a resolved or rejected to work - the rest is up\nto you.\n\nThe general idea is to setup your queries as usual, as if you wouldn't be\nworking with WebSockets. Most of the time, you will have your usual HTTP\nendpoints to query and mutate entities.\n\n```\n\nCopya-standard-query: copy code to clipboard\n\n```\n\nAdditionally, you can setup an app-wide that connects you to your WebSocket\nendpoint. How that works totally depends on which technology you are using. I've\nseen people subscribe to live data from . There's a great article about\nconnecting to . In my example, I will simply use the browser's native :\n\n```\n\nCopyuseReactQuerySubscription: copy code to clipboard\n\n```\n\nAfter we've setup the connection, we will likely have some sort of callback that\nwill be called when data comes in over the WebSocket. Again, what that data is\ndepends entirely on how you'd like to set it up. Inspired by from , I like to\nsend from the backend instead of complete data objects:\n\n```\n\nCopyevent-based-subscriptions: copy code to clipboard\n\n```\n\nThat's really all you need to make list and detail views update when you receive\nan event.\n\n  * `{ \"entity\": [\"posts\", \"list\"] }` will invalidate the posts list\n  * `{ \"entity\": [\"posts\", \"detail\"], id: 5 }` will invalidate a single post\n  * will invalidate everything post related\n\nplays really nice together with WebSockets. This approach avoids the problem of\nover pushing, because if we receive an event for an entity that we are not\ninterested in at the moment, nothing will happen. For example, if we are\ncurrently on the page, and we receive an update for , will make sure that the\nnext time we get to our page, it will be refetched. However, it will not refetch\nit right away, because we have no active observers. If we never go to that page\nagain, the pushed update would be completely unnecessary.\n\nOf course, if you have big data sets that receive small, but frequent updates,\nyou might still want to push partial data down the WebSocket.\n\nTitle of the post has changed? Just push the title. Number of likes have changed\n- push it down.\n\nFor these partial updates, you can use to directly update the query cache\ninstead of just invalidating it.\n\nThis will be a bit more cumbersome if you have multiple query keys for the same\ndata, e.g. if you have multiple filter criteria as part of the query key, or if\nyou want to update list detail view with the same message. is a relatively new\naddition to the library that will allow you to tackle this use-case as well:\n\n```\n\nCopypartial-updates: copy code to clipboard\n\n```\n\nIt's a bit too dynamic for my taste, doesn't handle addition or deletion, and\nTypeScript won't like it very much, so I'd personally rather stick to query\ninvalidation.\n\nNevertheless, here is a where I'm handling both type of events: invalidation and\npartial updates. (_Note: The custom hook is a bit more convoluted because in the\nexample, I use the same WebSocket to simulate the server round trip. Don't worry\nabout it if you have a real server_).\n\nReact Query comes with a of . This means that every query will be immediately\nconsidered as stale, which means it will refetch when a new subscriber mounts or\nwhen the user refocuses the window. It is aimed to keep your data as up-to-date\nas necessary.\n\nThis goal overlaps a lot with WebSockets, which update your data in real-time.\nWhy would I need to refetch at all if I just manually because the server just\ntold me to do so via a dedicated message?\n\nSo if you update all your data via websockets anyways, consider setting a high .\nIn my example, I just used . This means the data will be fetched initially via ,\nand then always come from the cache. Refetching only happens via the explicit\nquery invalidation.\n\nYou can best achieve this by setting global query defaults when creating the\n\n```\n\nCopyinfinite-stale-time: copy code to clipboard\n\n```\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/effective-react-query-keys\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * **#8: Effective React Query Keys**\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8272/0194f711-2ec1-78d3-b804-f17116a6e46c/>)\n\nare a very important core concept in React Query. They are necessary so that the\nlibrary can internally cache your data correctly and refetch automatically when\na dependency to your query changes. Lastly, it will allow you to interact with\nthe Query Cache manually when needed, for example, when updating data after a\nmutation or when you need to manually invalidate some queries.\n\nLet's quickly have a look at what these three points mean before showing you how\nI personally organize Query Keys to be able to do these things more effectively.\n\nInternally, the Query Cache is just a JavaScript object, where the keys are\nserialized Query Keys and the values are your Query Data plus meta information.\nThe keys are hashed in a , so you can use objects as well (on the top level,\nkeys have to be strings or arrays though).\n\nThe most important part is that keys need to be for your queries. If React Query\nfinds an entry for a key in the cache, it will use it. Please also be aware that\nyou cannot use the same key for . There is, after all, only Query Cache, and you\nwould share the data between these two. That is not good because infinite\nqueries have a fundamentally different structure than \"normal\" queries.\n\n```\n\n// üö® this won't work\n\n// ‚úÖ choose something else instead\n\n```\n\nThis is a important concept that cannot be emphasized enough, and it's also\nsomething that might take some time to \"click\". Most people think about queries,\nand especially refetching, in an way.\n\nI have a query, it fetches some data. Now I click this button and I want to\nrefetch, but with different parameters. I've seen many attempts that look like\nthis:\n\n```\n\nCopyimperative-refetch: copy code to clipboard\n\n// ‚ùì how do I pass parameters to refetch ‚ùì\n\n```\n\nThat's not what is for - it's for refetching .\n\nIf you have some that changes your data, all you need to do is to put it in the\nQuery Key, because React Query will trigger a refetch automatically whenever the\nkey changes. So when you want to apply your filters, just change your :\n\n```\n\nCopyquery-key-drives-the-query: copy code to clipboard\n\n// ‚úÖ set local state and let it drive the query\n\n```\n\nThe re-render triggered by the update will pass a different Query Key to React\nQuery, which will make it refetch. I have a more in-depth example in [#1:\nPractical React Query - Treat the query key like a dependency\narray](https://tkdodo.eu/blog/<practical-react-query#treat-the-query-key-like-a-\ndependency-array>).\n\nManual Interactions with the Query Cache are where the structure of your Query\nKeys is most important. Many of those interaction methods, like or support ,\nwhich allow you to fuzzily match your Query Keys.\n\nPlease note that these points reflect my personal opinion (as everything on this\nblog, actually), so don't take it as something that you absolutely must do when\nworking with Query Keys. I have found these strategies to work best when your\nApp becomes more complex, and they also scale quite well. You definitely don't\nneed to do this for a Todo App üòÅ.\n\nIf you haven't yet read by , please do. I don't believe that storing all your\nQuery Keys globally in will make things better. I keep my Query Keys next to\ntheir respective queries, co-located in a feature directory, so something like:\n\n```\n\n```\n\nThe file will contain everything React Query related. I usually only export\ncustom hooks, so the actual Query Functions as well as Query Keys will stay\nlocal.\n\nYes, Query Keys can be a string, too, but to keep things unified, I like to\nalways use Arrays. React Query will internally convert them to an Array anyhow,\nso:\n\n```\n\nCopyalways-use-array-keys: copy code to clipboard\n\n// üö® will be transformed to ['todos'] anyhow\n\n```\n\n‚Äã: With React Query v4, all keys need to be Arrays.\n\nStructure your Query Keys from to , with as many levels of granularity as you\nsee fit in between. Here's how I would structure a todos list that allows for\nfilterable lists as well as detail views:\n\n```\n\n['todos', 'list', { filters: 'all' }]\n\n['todos', 'list', { filters: 'done' }]\n\n```\n\nWith that structure, I can invalidate everything todo related with , all the\nlists or all the details, as well as target one specific list if I know the\nexact key. become a lot more flexible with this, because you can target all\nlists if necessary:\n\n```\n\nCopyupdates-from-mutation-responses: copy code to clipboard\n\n// ‚úÖ update the todo detail\n\n// ‚úÖ update all the lists that contain this todo\n\n```\n\nThis might not work if the structure of lists and details differ a lot, so\nalternatively, you can also of course just invalidate all the lists instead:\n\n```\n\nCopyinvalidate-all-lists: copy code to clipboard\n\n// ‚úÖ just invalidate all the lists\n\n```\n\nIf you know which list you are currently on, e.g. by reading the filters from\nthe url, and can therefore construct the exact Query Key, you can also combine\nthis two methods and call on your list and invalidate all the others:\n\n```\n\nCopycombine: copy code to clipboard\n\n// imagine a custom hook that returns\n\n// the current filters, stored in the url\n\n// ‚úÖ update the list we are currently on\n\n// ü•≥ invalidate all the lists,\n\n// but don't refetch the active one\n\n```\n\n‚Äã: In v4, has been replaced with . In the above example, that would be , because\nwe don't want to refetch anything.\n\nIn the examples above, you can see that I've been manually declaring the Query\nKeys a lot. This is not only error-prone, but it also makes changes harder in\nthe future, for example, if you find out that you'd like to add level of\ngranularity to your keys.\n\nThat's why I recommend one Query Key factory per feature. It's just a simple\nobject with entries and functions that will produce query keys, which you can\nthen use in your custom hooks. For the above example structure, it would look\nsomething like this:\n\n```\n\nCopyquery-key-factory: copy code to clipboard\n\n```\n\nThis gives me a lot of flexibility, as each level builds on top of another, but\nis still independently accessible:\n\n```\n\nCopyexamples: copy code to clipboard\n\n// üï∫ remove everything related\n\n// to the todos feature\n\n// üöÄ invalidate all the lists\n\n// üôå prefetch a single todo\n\n```\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Leveraging the Query Function Context\nURL: https://tkdodo.eu/blog/leveraging-the-query-function-context\n\n# Leveraging the Query Function Context\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * **#8a: Leveraging the Query Function Context**\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8274/0194f711-460f-7a62-b1f9-250d88c1250b/>)\n\nWe all strive to improve as engineers, and as time goes by, we hopefully succeed\nin that endeavour. Maybe we learn new things that invalidate or challenge our\nprevious thinking. Or we realise that patterns that we thought ideal would not\nscale to the level we now need them to.\n\nQuite some time has passed since I first started to use React Query. I think I\nlearned a great deal on that journey, and I've also \"seen\" a lot. I want my blog\nto be as up-to-date as possible, so that you can come back here and re-read it,\nknowing that the concepts are still valid. This is now more relevant than ever\nsince agreed to link to my blog from the official .\n\nThat's why I've decided to write this addendum to my article. Please make sure\nto read it first to have an understanding of what we are talking about.\n\nDon't use inline functions - leverage the Query Function Context given to you,\nand use a Query Key factory that produces object keys\n\nInline functions are by far the easiest way to pass parameters to your , because\nthey let you closure over other variables available in your custom hook. Let's\nlook at the evergreen todo example:\n\n```\n\nCopyinline-query-fn: copy code to clipboard\n\n// imagine this grabs the current user selection\n\n// from somewhere, e.g. the url\n\n// ‚úÖ The queryFn is an inline function that\n\n// closures over the passed state\n\n```\n\nMaybe you recognize the example - It's a slight variation of [#1: Practical\nReact Query - Treat the query key like a dependency\narray](https://tkdodo.eu/blog/<practical-react-query#treat-the-query-key-like-a-\ndependency-array>). This works great for simple examples, but it has a quite\nsubstantial problem when having lots of parameters. In bigger apps, it's not\nunheard of to have lots of filter and sorting options, and I've personally seen\nup to 10 params being passed.\n\nSuppose we want to add sorting to our query. I like to approach these things\nfrom the bottom up - starting with the and letting the compiler tell me what I\nneed to change next:\n\n```\n\nCopysorting-todos: copy code to clipboard\n\n```\n\nThis will certainly yield an error in our custom hook, where we call , so let's\nfix that:\n\n```\n\nCopyuseTodos-with-sorting: copy code to clipboard\n\n// üö® can you spot the mistake ‚¨áÔ∏è\n\n```\n\nMaybe you've already spotted the issue: Our got out of sync with our actual\ndependencies, and no red squiggly lines are screaming at us about it üòî. In the\nabove case, you'll likely spot the issue very fast (hopefully via an integration\ntest), because changing the sorting does not automatically trigger a refetch.\nAnd, let's be honest, it's also pretty obvious in this simple example. I have\nhowever seen the diverge from the actual dependencies a couple of times in the\nlast months, and with greater complexity, those can result in some hard to track\nissues. There's also a reason why React comes with the to avoid that.\n\nSo will React Query now come with its own eslint-rule? üëÄ\n\nWell, that would be one option. There is also the that solves this problem by\ngenerating query keys for you, including all your dependencies. React Query\nhowever comes with a different, built-in way of handling dependencies: The .\n\nThe is an object that is passed as argument to the . You've probably used it\nbefore when working with :\n\n```\n\nCopyuseInfiniteQuery: copy code to clipboard\n\n// this is the QueryFunctionContext ‚¨áÔ∏è\n\n```\n\nReact Query uses that object to inject information about the to the . In case of\n, you'll get the return value of injected as .\n\nHowever, the context also contains the that is used for this query (and we're\nabout to add more cool things to the context), which means you actually don't\nhave to closure over things, as they will be provided for you by React Query:\n\n```\n\nCopyquery-function-context: copy code to clipboard\n\n// üöÄ we can get all params from the queryKey\n\n// ‚úÖ no need to pass parameters manually\n\n```\n\nWith this approach, you basically have no way of using any additional parameters\nin your without also adding them to the . üéâ\n\n## How to type the QueryFunctionContext\n\nOne of the ambitions for this approach was to get full type safety and infer the\ntype of the from the passed to . This wasn't easy, but React Query supports that\nsince . If you inline the , you'll see that the types are properly inferred\n(thank you, Generics):\n\n```\n\nCopyquery-key-type-inference: copy code to clipboard\n\n// ‚úÖ this is safe because the queryKey is a tuple\n\n```\n\nThis is nice and all, but still has a bunch of flaws:\n\n  * You can still just use whatever you have in the closure to build your query\n  * Using the for building the url in the above way is still unsafe because you can stringify everything.\n\nThis is where query key factories come in again. If we have a typesafe query key\nfactory to build our keys, we can use the return type of that factory to type\nour . Here's how that might look:\n\n```\n\nCopytyped-query-function-context: copy code to clipboard\n\n// ü§Ø only accept keys that come from the factory\n\n// ‚úÖ build the key via the factory\n\n```\n\nThe type is exported by React Query. It takes one generic, which defines the\ntype of the . In the above example, we set it to be equal to whatever the\nfunction of our key factory returns. Since we use , all our keys will be\nstrictly typed tuples - so if we try to use a key that doesn't conform to that\nstructure, we will get a type error.\n\nWhile slowly transitioning to the above approach, I noticed that array keys are\nnot really performing that well. This becomes apparent when looking at how we\ndestruct the query key now:\n\n```\n\nCopyweird-destruct: copy code to clipboard\n\n```\n\nWe basically leave out the first two parts (our hardcoded scopes and ) and only\nuse the dynamic parts. Of course, it didn't take long until we added another\nscope at the beginning, which again led to wrongly built urls:\n\nSource: A PR I recently made\n\nTurns out, solve this problem really well, because you can use named\ndestructuring. Further, they have when used inside a query key, because fuzzy\nmatching for query invalidation works the same for objects as for arrays. Have a\nlook at the function if you're interested in how that works.\n\nKeeping that in mind, this is how I would construct my query keys with what I\nknow today:\n\n```\n\nCopyobject-keys: copy code to clipboard\n\n// ‚úÖ all keys are arrays with exactly one object\n\n// ‚úÖ extract named properties from the queryKey\n\n```\n\nObject query keys even make your fuzzy matching capabilities more powerful,\nbecause they have no order. With the array approach, you can tackle everything\ntodo related, all todo lists, or the todo list with a specific filter. With\nobjects keys, you can do that too, but also tackle all lists (e.g. todo lists\nand profile lists) if you want to:\n\n```\n\nCopyfuzzy-matching-with-object-keys: copy code to clipboard\n\n// üï∫ remove everything related to the todos feature\n\n// üöÄ reset all todo lists\n\n// üôå invalidate all lists across all scopes\n\n```\n\nThis can come in quite handy if you have multiple overlapping scopes that have a\nhierarchy, but where you still want to match everything belonging to the sub-\nscope.\n\nAs always: it depends. I've been loving this approach lately (which is why I\nwanted to share it with you), but there is certainly a tradeoff here between\ncomplexity and type safety. Composing query keys inside the key factory is\nslightly more complex (because still have to be an Array at the top level), and\ntyping the context depending on the return type of the key factory is also not\ntrivial. If your team is small, your api interface is slim and / or you're using\nplain JavaScript, you might not want to go that route. As per usual, choose\nwhichever tools and approaches make the most sense for your specific situation.\nüôå\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Placeholder and Initial Data in React Query\nURL: https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query\n\n# Placeholder and Initial Data in React Query\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * **#9: Placeholder and Initial Data in React Query**\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8273/0194f711-5cab-7651-844c-b67ea2c9c313/>)\n\nToday's article is all about improving the user experience when working with\nReact Query. Most of the time, we (and our users) dislike pesky loading\nspinners. They are a necessity sometimes, but we still want to avoid them if\npossible.\n\nReact Query already gives us the tools to get rid of them in many situations. We\nget stale data from the cache while background updates are happening, we can if\nwe know that we need it later, and we can even when our query keys change to\navoid those hard loading states.\n\nAnother way is to pre-fill the cache with data that we think will potentially be\nright for our use-case, and for that, React Query offers two different yet\nsimilar approaches: and .\n\nLet's start with what they both have in common before exploring their\ndifferences and the situations where one might be better suited than the other.\n\nAs already hinted, they both provide a way to pre-fill the cache with data that\nwe have synchronously available. It further means that if either one of these is\nsupplied, our query will not be in state, but will go directly to state. Also,\nthey can both be either a or a function that returns a , for those times when\ncomputing that value is expensive:\n\n```\n\nCopysuccess-queries: copy code to clipboard\n\n// ‚úÖ status will be success even if we have not yet fetched data\n\n// ‚úÖ same goes for initialData\n\n```\n\nLastly, neither has an effect if you already have data in your cache. So what\ndifference does it make if I use one or the other? To understand that, we have\nto briefly take a look at how (and on which \"level\") the options in React Query\nwork:\n\nFor each Query Key, there is only one cache entry. This is kinda obvious because\npart of what makes React Query great is the possibility to share the same data\n\"globally\" in our application.\n\nSome options we provide to will affect that cache entry, prominent examples are\nand . Since there is only cache entry, those options specify how to get data for\nthat entry, or when it can be garbage collected.\n\nAn observer in React Query is, broadly speaking, a subscription created for one\ncache entry. The observer watches the cache entry for changes and will be\ninformed every time something changes.\n\nThe basic way to create an observer is to call . Every time we do that, we\ncreate an observer, and our component will re-render when data changes. This of\ncourse means we can have multiple observers watching the same cache entry.\n\nBy the way, you can see how many observers a query has by the number on the left\nof the Query Key in the React Query Devtools (3 in this example):\n\nSome options that work on observer level would be or . In fact, what makes so\ngreat for is the ability to watch the same cache entry, but subscribe to\ndifferent slices of its data in different components.\n\nworks on cache level, while works on observer level. This has a couple of\nimplications:\n\nFirst of all, is persisted to the cache. It's one way of telling React Query: I\nhave \"good\" data for my use-case already, data that is as good as if it were\nfetched from the backend. Because it works on cache level, there can only be one\n, and that data will be put into the cache as soon as the cache entry is created\n(meaning when the first observer mounts). If you try to mount a second observer\nwith different , it won't do anything.\n\non the other hand is persisted to the cache. I like to see it as \"fake-it-till-\nyou-make-it\" data. It's \"not real\". React Query gives it to you so that you can\nshow it while the real data is being fetched. Because it works on observer\nlevel, you can theoretically even have different for different components.\n\nWith , you will always get a background refetch when you mount an observer for\nthe first time. Because the data is \"not real\", React Query will get the real\ndata for you. While this is happening, you will also get an flag returned from .\nYou can use this flag to visually hint to your users that the data they are\nseeing is in fact just placeholderData. It will transition back to as soon as\nthe real data comes in.\n\non the other hand, because data is seen as good and valid data that we actually\nput into our cache, respects . If you have a of zero (which is the default), you\nwill still see a background refetch.\n\nBut if you've set a (e.g. 30 seconds) on your query, React Query will see the\nand be like:\n\n> Oh, I'm getting fresh and new data here synchronously, thank you very much,\n> now I don't need to go to the backend because this data is good for 30\n> seconds.\n‚Äî React Query when it sees and\n\nIf that's not what you want, you can provide to your query. This will tell React\nQuery when this initialData has been created, and background refetches will be\ntriggered, taking this into account as well. This is extremely helpful when\nusing initialData from an existing cache entry by using the available timestamp:\n\n```\n\nCopyinitialDataUpdatedAt: copy code to clipboard\n\n// ‚úÖ will refetch in the background if our list query data\n\n// is older than the provided staleTime (30 seconds)\n\n```\n\nSuppose you provide or , and a background refetch is triggered, which then\nfails. What do you think will happen in each situation? I've hidden the answers\nso that you can try to come up with them for yourselves if you want before\nexpanding them.\n\nSince is persisted in the cache, the refetch error is treated like any other\nbackground error. Our query will be in state, but your will still be there.\n\nSince is \"fake-it-till-you-make-it\" data, and we didn't make it, we won't see\nthat data anymore. Our query will be in state, and our will be .\n\nAs always, that is totally up to you. I personally like to use when pre-filling\na query from another query, and I use for everything else.\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# React Query as a State Manager\nURL: https://tkdodo.eu/blog/react-query-as-a-state-manager\n\n# React Query as a State Manager\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * **#10: React Query as a State Manager**\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with MongoDB Atlas, the leading developer data\nplatform](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8268/0194f711-6fc8-7ab1-933d-11ec014a4138/>)\n\nReact Query is loved by many for drastically simplifying data fetching in React\napplications. So it might come as a bit of a surprise if I tell you that React\nQuery is in fact a data fetching library.\n\nIt doesn't fetch any data for you, and only a very small set of features are\ndirectly tied to the network (like , or ). This also becomes apparent when you\nwrite your first , and you have to use to actually get the data, like , , or\neven .\n\nSo if React Query is no data fetching library, what is it?\n\nReact Query is an async state manager. It can manage any form of asynchronous\nstate - it is happy as long as it gets a Promise. Yes, most of the time, we\nproduce Promises via data fetching, so that's where it shines. But it does more\nthan just handling loading and error states for you. It is a proper, real,\n\"global state manager\". The uniquely identifies your query, so as long you call\nthe query with the same key in two different places, they will get the same\ndata. This can be best abstracted with a custom hook so that we don't have to\naccess the actual data fetching function twice:\n\n```\n\nCopyasync-state-manager: copy code to clipboard\n\n// ‚úÖ will get exactly the same data as ComponentOne\n\n```\n\nThose components can be in your component tree. As long as they are under the\nsame , they will get the same data. React Query will also requests that would\nhappen at the same time, so in the above scenario, even though two components\nrequest the same data, there will be only one network request.\n\nBecause React Query manages async state (or, in terms of data fetching: server\nstate), it assumes that the frontend application doesn't \"own\" the data. And\nthat's totally right. If we display data on the screen that we fetch from an\nAPI, we only display a \"snapshot\" of that data - the version of how it looked\nwhen we retrieved it. So the question we have to ask ourselves is:\n\nIs that data still accurate after we fetch it?\n\nThe answer depends totally on our problem domain. If we fetch a Twitter post\nwith all its likes and comments, it is likely outdated (stale) pretty fast. If\nwe fetch exchange rates that update on a daily basis, well, our data is going to\nbe quite accurate for some time even without refetching.\n\nReact Query provides the means to our view with the actual data owner - the\nbackend. And by doing so, it errs on the side of updating often rather than not\nupdating often enough.\n\nTwo approaches to data fetching were pretty common before libraries like React\nQuery came to the rescue:\n\n  * fetch once, distribute globally, rarely update This is pretty much what I myself have been doing with redux a lot. Somewhere, I dispatch an action that initiates the data fetching, usually on mount of the application. After we get the data, we put it in a global state manager so that we can access it everywhere in our application. After all, many components need access to our Todo list. Do we refetch that data? No, we have \"downloaded\" it, so we have it already, why should we? Maybe if we fire a POST request to the backend, it will be kind enough to give us the \"latest\" state back. If you want something more accurate, you can always reload your browser window...\n  * fetch on every mount, keep it local Sometimes, we might also think that putting data in global state is \"too much\". We only need it in this Modal Dialog, so why not fetch it when the Dialog opens. You know the drill: , empty dependency array (throw an eslint-disable at it if it screams), and so on ... Of course, we now show a loading spinner every time the Dialog opens until we have the data. What else can we do, the local state is gone...\n\nBoth of these approaches are pretty sub-optimal. The first one doesn't update\nour local cache often enough, while the second one potentially re-fetches too\noften, and also has a questionable ux because data is not there when we fetch\nfor the second time.\n\nSo how does React Query approach these problems?\n\nYou might have heard this before, it's the caching mechanism that React Query\nuses. It's nothing new - you can read about the [HTTP Cache-Control Extensions\nfor Stale Content\nhere](https://tkdodo.eu/blog/<https:/datatracker.ietf.org/doc/html/rfc5861>). In\nsummary, it means React Query will cache data for you and give it to you when\nyou need it, even if that data might not be up-to-date (stale) anymore. The\nprinciple is that stale data is better than no data, because no data usually\nmeans a loading spinner, and this will be perceived as \"slow\" by users. At the\nsame time, it will try to perform a background refetch to revalidate that data.\n\nCache invalidation is pretty hard, so when do you decide it's time to ask the\nbackend again for new data? Surely we can't just do this every time a component\nthat calls re-renders. That would be insanely expensive, even by modern\nstandards.\n\nSo React Query is being smart and chooses strategic points for triggering a\nrefetch. Points that seem to be a good indicator for saying: \"Yep, now would be\na good time to go get some data\". These are:\n\n  * Whenever a new component that calls mounts, React Query will do a revalidation.\n  * Whenever you focus the browser tab, there will be a refetch. This is my favourite point in time to do a revalidation, but it's often misunderstood. During development, we switch browser tabs very often, so we might perceive this as \"too much\". In production however, it most likely indicates that a user who left our app open in a tab now comes back from checking mails or reading twitter. Showing them the latest updates makes perfect sense in this situation.\n  * If you lose your network connection and regain it, it's also a good indicator to revalidate what you see on the screen.\n\nFinally, if you, as the developer of your app, know a good point in time, you\ncan invoke a manual invalidation via . This comes in very handy after you\nperform a mutation.\n\n### Letting React Query do its magic\n\nI love , but as I said before, they are geared towards keeping things up-to-\ndate, to minimize the amount of network requests. This is mainly because\ndefaults to , which means that every time you e.g. mount a new component\ninstance, you will get a background refetch. If you do this a lot, especially\nwith mounts in short succession that are not in the same render cycle, you might\nsee of fetches in the network tab. That's because React Query can't deduplicate\nin such situations:\n\n```\n\nCopymounts-in-short-succession: copy code to clipboard\n\n// ‚ö†Ô∏è mounts conditionally, only after we already have data\n\n// ‚ö†Ô∏è will thus trigger a second network request\n\n```\n\n> What's going on here, I just fetched my data 2 seconds ago, why is there\n> another network request happening? This is insane!\n‚Äî Legit reaction when using React Query for the first time\n\nAt that point, it might seem like a good idea to either pass down via props, or\nto put it in to avoid prop drilling, or to just turn off the / flags because all\nof this fetching is just too much!\n\nGenerally, there is nothing wrong with passing data as props. It's the most\nexplicit thing you can do, and would work well in the above example. But what if\nwe tweak the example a bit towards a more real-life situation:\n\n```\n\nCopylazy-second-component: copy code to clipboard\n\n// yes, I leave out error handling, this is \"just\" an example\n\n   // ‚úÖ show ComponentTwo after the button has been clicked\n\n```\n\nIn this example, our second component (which also depends on the todo data) will\nonly mount after the user clicks a button. Now imagine our user clicks on that\nbutton after some minutes. Wouldn't a background refetch be nice in that\nsituation, so that we can see the up-to-date values of our todo list?\n\nThis wouldn't be possible if you chose any of the aforementioned approaches that\nbasically bypass what React Query wants to do.\n\nSo how can we have our cake and eat it, too?\n\nMaybe you've already guessed the direction in which I want to go: The solution\nwould be to set to a value you are comfortable with for your specific use-case.\nThe key thing to know is:\n\nAs long as data is fresh, it will always come from the cache only. You will not\nsee a network request for fresh data, no matter how often you want to retrieve\nit.\n\nThere is also no \"correct\" value for . In many situations, the defaults work\nreally well. Personally, I like to set it to a minimum of 20 seconds to\ndeduplicate requests in that time frame, but it's totally up to you.\n\nSince v3, React Query supports a great way of setting default values per Query\nKey via . So if you follow the patterns I've outlined in [#8: Effective React\nQuery Keys](https://tkdodo.eu/blog/<effective-react-query-keys>), you can set\ndefaults for any granularity you want, because passing Query Keys to follows the\nstandard partial matching that e.g. also have:\n\n```\n\nCopysetQueryDefaults: copy code to clipboard\n\n// ‚úÖ globally default to 20 seconds\n\n// üöÄ everything todo-related will have\n\n// a 1 minute staleTime\n\n```\n\n## A note on separation of concerns\n\nIt is a seemingly legit concern that adding hooks like to components of all\nlayers in your app mixes responsibilities of what a component should do. Back in\nthe , the \"smart-vs-dumb\", \"container-vs-presentational\" component pattern was\nubiquitous. It promised clear separation, decoupling, reusability and ease of\ntestability because presentational components would just \"get props\". It also\nled to lots of prop drilling, boilerplate, patterns that were hard to statically\ntype (üëã higher-order-components) and arbitrary component splits.\n\nThat changed a lot when hooks came around. You can now , or (if you're using\nredux) everywhere, and thus inject dependencies into your component. You can\nargue that doing so makes your component more coupled. You can also say that\nit's now more independent because you can move it around freely in your app, and\nit will just work on its own.\n\nI can totally recommend watching [Hooks, HOCS, and Tradeoffs (‚ö°Ô∏è) / React Boston\n2019](https://tkdodo.eu/blog/<https:/www.youtube.com/watch?v=xiKMbmDv-Vw>) by\nredux maintainer .\n\nIn summary, it's all tradeoffs. There is no free lunch. What might work in one\nsituation might not work in others. Should a reusable component do data\nfetching? Probably not. Does it make sense to split your into a and a that\npasses data down? Also, probably not. So it's on us to know the tradeoffs and\napply the right tool for the right job.\n\nReact Query is great at managing async state globally in your app, if you let\nit. Only turn off the refetch flags if you know that make sense for your use-\ncase, and resist the urge to sync server data to a different state manager.\nUsually, customizing is all you need to get a great ux while also being in\ncontrol of how often background updates happen.\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/react-query-error-handling\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * **#11: React Query Error Handling**\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8273/0194f711-8542-7fd2-84a1-299b66d85a08/>)\n\nHandling errors is an integral part of working with asynchronous data,\nespecially data fetching. We have to face it: Not all requests will be\nsuccessful, and not all Promises will be fulfilled.\n\nOftentimes, it is something that we don't focus on right from the beginning\nthough. We like to handle \"sunshine cases\" first where error handling becomes an\nafterthought.\n\nHowever, not thinking about how we are going to handle our errors might\nnegatively affect user experience. To avoid that, let's dive into what options\nReact Query offers us when it comes to error handling.\n\nReact Query needs a rejected Promise in order to handle errors correctly.\nLuckily, this is exactly what you'll get when you work with libraries like .\n\nIf you are working with or other libraries that give you a rejected Promise on\nerroneous status codes like 4xx or 5xx, you'll have to do the transformation\nyourself in the . This is covered in .\n\nLet's see how most examples around displaying errors look like:\n\n```\n\nCopythe-standard-example: copy code to clipboard\n\n// ‚úÖ standard error handling\n\n// could also check for: todos.status === 'error'\n\n```\n\nHere, we're handling error situations by checking for the boolean flag (which is\nderived from the enum) given to us by React Query.\n\nThis is certainly okay for some scenarios, but has a couple of drawbacks, too:\n\n  1. It doesn't handle background errors very well: Would we really want to unmount our complete Todo List just because a background refetch failed? Maybe the api is temporarily down, or we reached a rate limit, in which case it might work again in a few minutes. You can have a look at [#4: Status Checks in React Query](https://tkdodo.eu/blog/<status-checks-in-react-query>) to find out how to improve that situation.\n  2. It can become quite boilerplate-y if you have to do this in every component that wants to use a query.\n\nTo solve the second issue, we can use a great feature provided directly by React\nitself:\n\nare a general concept in React to catch runtime errors that happen during\nrendering, which allows us to react (pun intended) properly to them and display\na fallback UI instead.\n\nThis is nice because we can wrap our components in Error Boundaries at any\ngranularity we want, so that the rest of the UI will be unaffected by that\nerror.\n\nOne thing that Error Boundaries do is catch asynchronous errors, because those\ndo not occur during rendering. So to make Error Boundaries work in React Query,\nthe library internally catches the error for you and re-throws it in the next\nrender cycle so that the Error Boundary can pick it up.\n\nI think this is a pretty genius yet simple approach to error handling, and all\nyou need to do to make that work is pass the flag to your query (or provide it\nvia a default config):\n\n```\n\nCopythrowOnError: copy code to clipboard\n\n// ‚úÖ will propagate all fetching errors\n\n// to the nearest Error Boundary\n\n```\n\nStarting with , you can even customize which errors should go towards an Error\nBoundary, and which ones you'd rather handle locally by providing a function to\n:\n\n```\n\nCopygranular-error-boundaries: copy code to clipboard\n\n// üöÄ only server errors will go to the Error Boundary\n\n```\n\nThis also works for , and is quite helpful for when you're doing form\nsubmissions. Errors in the 4xx range can be handled locally (e.g. if some\nbackend validation failed), while all 5xx server errors can be propagated to the\nError Boundary.\n\nFor some use-cases, it might be better to show error toast notifications that\npop up somewhere (and disappear automatically) instead of rendering Alert\nbanners on the screen. These are usually opened with an imperative api, like the\none offered by :\n\n```\n\nCopyreact-hot-toast: copy code to clipboard\n\n```\n\nSo how can we do this when getting an error from React Query?\n\n```\n\nCopythe-onError-callback: copy code to clipboard\n\n// ‚ö†Ô∏è looks good, but is maybe _not_ what you want\n\n```\n\nAt first glance, it looks like the callback is exactly what we need to perform a\nside effect if a fetch fails, and it will also work - for as long as we only use\nthe custom hook once!\n\nYou see, the callback on is called for every , which means if you call twice in\nyour application, you will get two error toasts, even though only one network\nrequest fails.\n\nConceptually, you can imagine that the onError callback functions similar to a .\nSo if we expand the above example to that syntax, it will become more apparent\nthat this will run for every consumer:\n\n```\n\nCopyuseEffect-error-toast: copy code to clipboard\n\n// üö® effects are executed for every component\n\n// that uses this custom hook individually\n\n```\n\nOf course, if you don't add the callback to your custom hook, but to the\ninvocation of the hook, this is totally fine. But what if we don't really want\nto notify all Observers that our fetch failed, but just notify the user that the\nunderlying fetch failed? For that, React Query has callbacks on a different\nlevel:\n\nThe global callbacks need to be provided when you create the , which happens\nimplicitly when you create a , but you can also customize that:\n\n```\n\nCopyquery-cache-callbacks: copy code to clipboard\n\n```\n\nThis will now only show an error toast once for each query, which exactly what\nwe want.ü•≥ It is also likely the best place to put any sort of error tracking or\nmonitoring that you want to perform, because it's guaranteed to run only once\nper request and be overwritten like e.g. the defaultOptions.\n\nThe three main ways to handle errors in React Query are:\n\n  * the callback (on the query itself or the global QueryCache / MutationCache)\n\nYou can mix and match them however you want, and what I personally like to do is\nshow error toasts for background refetches (to keep the stale UI intact) and\nhandle everything else locally or with Error Boundaries:\n\n```\n\nCopybackground-error-toasts: copy code to clipboard\n\n// üéâ only show error toasts if we already have data in the cache\n\n// which indicates a failed background update\n\n```\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Mastering Mutations in React Query\nURL: https://tkdodo.eu/blog/mastering-mutations-in-react-query\n\n# Mastering Mutations in React Query\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * **#12: Mastering Mutations in React Query**\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8273/0194f711-9937-7413-93b2-c363e5e7b72a/>)\n\nWe've covered a lot of ground already when it comes to the features and concepts\nReact Query provides. Most of them are about data - via the hook. There is\nhowever a second, integral part to working with data: updating it.\n\nFor this use-case, React Query offers the hook.\n\nGenerally speaking, mutations are functions that have a side effect. As an\nexample, have a look at the method of Arrays: It has the side effect of the\narray in place where you're pushing a value to:\n\n```\n\nCopymutable-array-push: copy code to clipboard\n\n```\n\nThe counterpart would be , which can also add values to an array, but it will\nreturn a new Array instead of directly manipulating the Array you operate on:\n\n```\n\nCopyimmutable-array-concat: copy code to clipboard\n\n```\n\nAs the name indicates, also has some sort of side effect. Since we are in the\ncontext of with React Query, mutations describe a function that performs such a\nside effect . Creating a todo in your database would be a mutation. Logging in a\nuser is also a classic mutation, because it performs the side effect of creating\na token for the user.\n\nIn some aspects, is very similar to . In others, it is quite different.\n\nwill track the state of a mutation, just like does for queries. It'll give you ,\nand fields to make it easy for you to display what's going on to your users.\n\nYou'll also get the same nice callbacks that has: , and . But that's about where\nthe similarities end.\n\nuseQuery is declarative, useMutation is imperative.\n\nBy that, I mean that queries mostly run automatically. You define the\ndependencies, but React Query takes care of running the query immediately, and\nthen also performs smart background updates when deemed necessary. That works\ngreat for queries because we want to keep what we see on the screen with the\nactual data on the backend.\n\nFor mutations, that wouldn't work well. Imagine a new todo would be created\nevery time you focus your browser window ü§®. So instead of running the mutation\ninstantly, React Query gives you a function that you can invoke whenever you\nwant to make the mutation:\n\n```\n\nCopyimperative-mutate: copy code to clipboard\n\n// this doesn't really do anything yet\n\n// ‚úÖ mutation is invoked when the form is submitted\n\n```\n\nAnother difference is that mutations don't share state like does. You can invoke\nthe same call multiple times in different components and will get the same,\ncached result returned to you - but this won't work for mutations.\n\nMutations are, per design, not directly coupled to queries. A mutation that\nlikes a blog post has no ties towards the query that fetches that blog post. For\nthat to work, you would need some sort of underlying schema, which React Query\ndoesn't have.\n\nTo have a mutation reflect the changes it made on our queries, React Query\nprimarily offers two ways:\n\nThis is conceptually the simplest way to get your screen up-to-date. Remember,\nwith server state, you're only ever displaying a snapshot of data from a given\npoint in time. React Query tries to keep that up-to-date of course, but if\nyou're deliberately changing server state with a mutation, this is a great point\nin time to tell React Query that some data you have cached is now \"invalid\".\nReact Query will then go and refetch that data if it's currently in use, and\nyour screen will update automatically for you once the fetch is completed. The\nonly thing you have to tell the library is queries you want to invalidate:\n\n```\n\nCopyinvalidation-from-mutation: copy code to clipboard\n\n// ‚úÖ refetch the comments list for our blog post\n\n```\n\nQuery invalidation is pretty smart. Like all , it uses fuzzy matching on the\nquery key. So if you have multiple keys for your comments list, they will all be\ninvalidated. However, only the ones that are currently active will be refetched.\nThe rest will be marked as stale, which will cause them to be refetched the next\ntime they are used.\n\nAs an example, let's assume we have the option to sort our comments, and at the\ntime the new comment was added, we have two queries with comments in our cache:\n\n```\n\n['posts', 5, 'comments', { sortBy: ['date', 'asc'] }\n\n['posts', 5, 'comments', { sortBy: ['author', 'desc'] }\n\n```\n\nSince we're only displaying one of them on the screen, will refetch that one and\nmark the other one as stale.\n\nSometimes, you don't want to refetch data, especially if the mutation already\nreturns everything you need to know. If you have a mutation that updates the\ntitle of your blog post, and the backend returns the complete blog post as a\nresponse, you can update the query cache directly via :\n\n```\n\nCopyupdate-from-mutation-response: copy code to clipboard\n\n// üí° response of the mutation is passed to onSuccess\n\n// ‚úÖ update detail view directly\n\n```\n\nPutting data into the cache directly via will act as if this data was returned\nfrom the backend, which means that all components using that query will re-\nrender accordingly.\n\nI'm showing some more examples of direct updates and the combination of both\napproaches in [#8: Effective React Query\nKeys](https://tkdodo.eu/blog/<effective-react-query-keys#structure>).\n\nI personally think that most of the time, invalidation should be preferred. Of\ncourse, it depends on the use-case, but for direct updates to work reliably, you\nneed more code on the frontend, and to some extent duplicate logic from the\nbackend. Sorted lists are for example pretty hard to update directly, as the\nposition of my entry could've potentially changed because of the update.\nInvalidating the whole list is the \"safer\" approach.\n\nOptimistic updates are one of the key selling points for using React Query\nmutations. The cache gives us data instantly when switching between queries,\nespecially when combined with . Our whole UI feels very snappy because of it, so\nwhy not get the same advantage for mutations as well?\n\nA lot of the time, we are quite certain that an update will go through. Why\nshould the user wait for a couple of seconds until we get the okay from the\nbackend to show the result in the UI? The idea of optimistic updates is to fake\nthe success of a mutation even before we have sent it to the server. Once we get\na successful response back, all we have to do is invalidate our view again to\nsee the real data. In case the request fails, we're going to roll back our UI to\nthe state from before the mutation.\n\nThis works great for small mutations where instant user feedback is actually\nrequired. There is nothing worse than having a toggle button that performs a\nrequest, and it doesn't react at all until the request has completed. Users will\ndouble or even triple click that button, and it will just feel \"laggy\" all over\nthe place.\n\nI've decided to show an additional example. The cover that topic very well, and\nthey also have a codesandbox example .\n\nI further think that optimistic updates are a bit over-used. Not every mutation\nneeds to be done optimistically. You should really be sure that it rarely fails,\nbecause the UX for a rollback is not great. Imagine a Form in a Dialog that\ncloses when you submit it, or a redirect from a detail view to a list view after\nan update. If those are done prematurely, they are hard to undo.\n\nAlso, be sure that the instant feedback is really required (like in the toggle\nbutton example above). The code needed to make optimistic updates work is non-\ntrivial, especially compared to \"standard\" mutations. You need to mimic what the\nbackend is doing when you're faking the result, which can be as easy as flipping\na Boolean or adding an item to an Array, but it might also get more complex\nreally fast:\n\n  * If the todo you're adding needs an id, where do you get it from?\n  * If the list you're currently viewing is sorted, will you insert the new entry at the right position?\n  * What if another user has added something else in the meantime - will our optimistically added entry switch positions after a refetch?\n\nAll these edge cases might make the UX actually worse in some situations, where\nit might be enough to disable the button and show a loading animation while the\nmutation is in-flight. As always, choose the right tool for the right job.\n\nFinally, let's dive into some things that are good to know when dealing with\nmutations that might not be that obvious initially:\n\nPromises returned from the mutation callbacks are awaited by React Query, and as\nit so happens, returns a Promise. If you want your mutation to stay in state\nwhile your related queries update, you have to return the result of from the\ncallback:\n\n```\n\nCopyawaited-promises: copy code to clipboard\n\n// üéâ will wait for query invalidation to finish\n\n// üöÄ fire and forget - will not wait\n\n```\n\ngives you two functions - and . What's the difference, and when should you use\nwhich one?\n\ndoesn't return anything, while returns a Promise containing the result of the\nmutation. So you might be tempted to use when you need access to the mutation\nresponse, but I would still argue that you should almost always use .\n\nYou can still get access to the or the via the callbacks, and you don't have to\nworry about error handling: Since gives you control over the Promise, you also\nhave to catch errors manually, or you might get an .\n\n```\n\nCopyaccessing-mutation-data: copy code to clipboard\n\n// ‚úÖ accessing the response via onSuccess\n\n// üö® works, but is missing error handling\n\n// üòï this is okay, but look at the verbosity\n\n```\n\nHandling errors is not necessary with , because React Query catches (and\ndiscards) the error for you internally. It is literally implemented with: üòé\n\nThe only situations where I've found to be superior is when you really need the\nPromise for the sake of having a Promise. This can be necessary if you want to\nfire off multiple mutations concurrently and want to wait for them all to be\nfinished, or if you have dependent mutations where you'd get into callback hell\nwith the callbacks.\n\n### Mutations only take one argument for variables\n\nSince the last argument to is the options object, can currently only take\nargument for variables. This is certainly a limitation, but it can be easily\nworked around by using an object:\n\n```\n\nCopymultiple-variables: copy code to clipboard\n\n// üö® this is invalid syntax and will NOT work\n\n// ‚úÖ use an object for multiple variables\n\n```\n\nTo read more on why that is currently necessary, have a look at .\n\n### Some callbacks might not fire\n\nYou can have callbacks on as well as on itself. It is important to know that the\ncallbacks on fire before the callbacks on . Further, the callbacks on might not\nfire if the component unmounts before the mutation has finished.\n\nThat's why I think it's a good practice to separate concerns in your callbacks:\n\n  * Do things that are absolutely necessary and logic related (like query invalidation) in the callbacks.\n  * Do UI related things like redirects or showing toast notifications in callbacks. If the user navigated away from the current screen before the mutation finished, those will purposefully not fire.\n\nThis separation is especially neat if comes from a custom hook, as this will\nkeep query related logic in the custom hook while UI related actions are still\nin the UI. This also makes the custom hook more reusable, because how you\ninteract with the UI might vary on a case by case basis - but the invalidation\nlogic will likely always be the same:\n\n```\n\nCopyseparate-concerns: copy code to clipboard\n\n// ‚úÖ always invalidate the todo list\n\n// ‚úÖ only redirect if we're still on the detail page\n\n// when the mutation finishes\n\n```\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/offline-react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[An easy, simple SMS API. ClickSend is made for\ndevelopers.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8204/0194f711-b0c5-7352-991d-d4b69825b93e/>)\n\nI've said it time and time again - React Query is an . As long as you give it a\nPromise, resolved or rejected, the library is happy. Doesn't matter where that\nPromise comes from.\n\nThere are many ways to produce promises, but by far the biggest use-case is data\nfetching. Very often, that requires an active network connection. But sometimes,\nespecially on mobile devices where the network connection can be unreliable, you\nneed your app to also work without it.\n\nReact Query is very well-equipped to handle offline scenarios. Because it\nprovides a caching layer, as long as the cache is filled, you can keep working\neven if you don't have a network connection. Let's look at a couple of edge-case\nscenarios where v3 will not work as expected. I will use our basic post list /\npost detail for illustration:\n\n### 1) no data in the cache\n\nAs I said, in v3, things work well as long as the cache is filled. An edge case\nscenario where things get weird would be the following:\n\n  * You have a good network connection and navigate to the list view\n  * You lose connection and click on a post.\n\nWhat happens is that your query will stay in state until you regain connection.\nAlso, you can see a failed network request in the browser devtools. That is\nbecause React Query will always fire off the first request, and if that fails,\nit will pause retries if you have no network connection.\n\nFurther, the React Query Devtools will show that your query is , which is not\nentirely true. The query is actually , but we have no concept to represent that\nstate - it's a hidden implementation detail.\n\nSimilarly, if you have turned off retries altogether in the above scenario, your\nquery will go to error state immediately, with no way of stopping that.\n\nWhy do I need for my query to if I have no network connection ü§∑‚Äç‚ôÇÔ∏è?\n\n### 3) queries that don't need the network\n\nQueries that don't need a network connection to work (e.g. because they do an\nexpensive async processing in a web worker) will be paused until you regain\nnetwork connection if they fail for some other reason. Also, those queries won't\nrun on window focus because that feature is completely disabled if you have no\nnetwork connection.\n\nIn summary, there are two major issues: In some cases, React Query assumes that\nnetwork connection is needed when that might not be true (case 3), and in other\ncases, React Query fires off a query even though it probably shouldn't (cases 1\nand 2).\n\nIn v4, we've tried to tackle this problem holistically with a new setting. With\nthis, we can clearly distinguish between and queries. It is an option for as\nwell as , which means you can set it globally or on a per-query basis. After\nall, you might have some queries that need network connection, and some that\ndon't.\n\nThis is the new default mode in v4, as we expect most users to use React Query\nin combination with data fetching. In short, with this setting, we assume that a\nquery can only run if it has an active network connection.\n\nSo what happens if you want to run a query that needs network connection when\nyou don't have one? The query will go to a new state. That state is secondary to\nthe main state that the query can be in: , or , because you can lose your\nnetwork connection at any time.\n\nThis means you can be in state and , for example, if you've fetched data\nsuccessfully once but a background refetch got paused.\n\nOr, you can be in state and if a query mounts for the first time.\n\nWe've always had the flag that indicated that a query was running. Similar to\nthe new state, a query could be and , or it could be and . Background refetches\ngive you a of possible states to be in (üëã state machines).\n\nAs and are mutually exclusive, we've combined them into the new that now gets\nreturned from :\n\n  * : The query is really executing - a request is in-flight.\n  * : The query is not executing - it is paused until you have regained your connection.\n  * : The query is currently not running.\n\nAs a rule of thumb, the of the query will give you information about the : means\nyou'll always have data, means you don't have data yet.\n\nOn the other hand, the gives you information about the : is it running or not?\nThe and flags are derived from that status.\n\nLet's take a look at how from above can look like in v4. Please notice the new\nnetwork mode toggle button in the RQ devtools. It's pretty cool because it\ndoesn't actually turn off your network - it just makes React Query that there is\nno network for testing purposes. Yes, I am quite proud of it. üòä\n\nWe can clearly see the state the query is in () due to the new purple status\nbadge. Also, the first network request is made once we turn the network back on.\n\nIn this mode, React Query does not care about your network connection at all.\nQueries will always fire, and they will never be paused. This is most useful if\nyou use React Query for something data fetching.\n\nThis mode is very similar to how React Query worked in v3. The first request\nwill be made, and if that fails, retries will be paused. This mode is useful if\nyou're using an additional caching layer like the browser cache on top of React\nQuery.\n\nLet's take the GitHub repo API as an example. It sends the following response\nheaders:\n\n```\n\n```\n\nwhich means that for the next 60 seconds, if you request that resource again,\nthe response will come from the browser cache. The neat thing about this is that\nit works while you're offline, too! Service workers, e.g. for , work in a\nsimilar way by intercepting the network request and delivering cached responses\nif they are available.\n\nNow those things wouldn't work if React Query would decide to fire the request\nbecause you have no network connection, like the default mode does. To intercept\na fetch request, it must happen :) So if you have this additional cache layer,\nmake sure to use .\n\nIf the first request goes out, and you hit the cache - great, your query will go\nto state, and you'll get that data. And if you have a cache miss, you'll likely\nget a network error, after which React Query will pause the retries, which will\nput your query into the state. It's the best of both worlds. üôå\n\n## What does all of this mean for me, exactly?\n\nNothing, unless you want to. You can still decide to ignore that new and only\ncheck for - React Query will behave just like before (well - from above will\neven work better because you won't see the network error).\n\nHowever, if making your app robust for situations where you have no network\nconnection is a priority for you, you now have the option to react to the\nexposed and act accordingly.\n\nWhat you do with that new status is up to you. I'm excited to see which ux\npeople will build on top of this. üöÄ\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/react-query-and-forms\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * **#14: React Query and Forms**\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[video to see firsthand how to upgrade your site with end-to-end AI\nSearch.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8298/0194f711-c3b3-7531-aefa-2c14586550a5/>)\n\nForms are an important part in many web applications as the primary means to\nupdate data. We are using React Query not only to fetch data (), but also to\nmodify it (), so we need to somehow integrate our beloved async state manager\nwith forms.\n\nThe good news is that realistically, there isn't anything special about forms:\nIt is still just a bunch of html elements that we render in order to display\nsome data. However, as we'd also like to that data, the lines between what is\nServer State and what is Client State start to blur a bit, which is where the\ncomplexity might come in.\n\n## Server State vs. Client State\n\nTo recap, is state that we do not own, that is mostly async and where we only\nsee a snapshot of how the data looked like the last time we fetched it.\n\nis state that the frontend has full control over, is mostly synchronous and\nwhere we know the accurate value of it at all times.\n\nWhen we display a list of Persons, that is undoubtedly Server State. But what\nhappens when we click on a Person to show their details in a Form with the\nintention of maybe updating some values? Does that Server State now become\nClient State? Is it a hybrid?\n\nI have gone on the record already about how I am not a fan of copying state from\none state manager to another, be it or copying state from [React Query to local\nstate](https://tkdodo.eu/blog/<practical-react-query#keep-server-and-client-\nstate-separate>).\n\nI do think that forms can be an exception to this rule though, if you are doing\nit deliberately and know about the tradeoffs (everything is a tradeoff after\nall). When rendering our Person form, we very likely want to treat the Server\nState as data only. We fetch the firstName and lastName, put it into the form\nstate, and then let the user update it.\n\nLet's take a look at an example:\n\n```\n\nCopysimple-form: copy code to clipboard\n\n```\n\nThis works incredibly well - so what are those tradeoffs?\n\nYou might know that would also take defaultValues directly for the whole form,\nwhich would be pretty nice for larger forms. However, because we cannot call\nhooks conditionally, and because our is on the first render cycle (as we need to\nfetch it first), we cannot just do this in the same component:\n\n```\n\nCopyno-default-values: copy code to clipboard\n\n// üö® this will initialize our form with undefined\n\n```\n\nWe'd have the same problem when copying into , or when using uncontrolled forms\n(which react-hook-form does under the hood by the way). The best solution to\nthis would be to split up the form into its own component:\n\n```\n\nCopyseparate-form: copy code to clipboard\n\n```\n\nThis is not too bad, as it separates our data fetching from the presentation.\nI'm personally not a big fan of such a split, but it does get the job done here.\n\nReact Query is all about keeping your UI up-to-date with Server State. As soon\nas we copy that state somewhere else, React Query cannot do its job anymore. if\na background refetch happens for whatever reason, and it yields new data, our\nform state will not update with it. This is likely not problematic if we are the\nonly one working on that form state (like a form for our profile page). If\nthat's the case, we should likely at least disable background updates by setting\na higher on our query. After all, why would we keep querying our server if the\nupdates will not be reflected on the screen?\n\n```\n\nCopyno-background-updates: copy code to clipboard\n\n// ‚úÖ opt out of background updates\n\n```\n\nThis approach can get problematic on bigger forms and in collaborative\nenvironments. The bigger the form, the longer it takes our users to fill it out.\nIf multiple people work on the same form, but on different fields, whoever\nupdates last might override the values that others have changed, because they\nstill see a partially outdated version on their screen.\n\nNow react hook form allows you to detect which fields have been changed by the\nuser and only send \"dirty\" fields to the server with some user land code (see ),\nwhich is pretty cool. However, this still doesn't show the latest values with\nupdates made by other users to you. Maybe you would change your input had you\nknown that a certain field was changed in the meantime by someone else.\n\nSo what would we need to do to still reflect background updates while we are\nediting our form?\n\nOne approach is to rigorously separate the states. We'll keep the Server State\nin React Query, and only track the changes the user has made with our Client\nState. The source of truth that we display then to our users is from those two:\nIf the user has changed a field, we show the Client State. If not, we fall back\nto the Server State:\n\n```\n\nCopyseparate-states: copy code to clipboard\n\n// ‚úÖ derive state from field value (client state)\n\n// and data (server state)\n\n```\n\nWith that approach, we can keep background updates on, because it will still be\nrelevant for untouched fields. We are no longer bound to the initialState that\nwe had when we first rendered the form. As always, there are caveats here as\nwell:\n\nAs far as I'm aware, there is no good way to achieve this with uncontrolled\nfields, which is why I've resorted to using controlled fields in the above\nexample. Please let me know if I'm missing something.\n\n### Deriving state might be difficult\n\nThis approach works best for shallow forms, where you can easily fall back to\nthe Server State using nullish coalesce, but it could be more difficult to merge\nproperly with nested objects. It might also sometimes be a questionable user\nexperience to just change form values in the background. A better idea might be\nto just highlight values that are out of sync with the Server State and let the\nuser decide what to do.\n\nWhichever way you choose, try to be aware of the advantages / disadvantages that\neach approach brings.\n\nApart from those two principal ways of setting up your form, here are some\nsmaller, but nonetheless important tricks to integrate React Query with forms:\n\nTo prevent a form from being submitted twice, you can use the prop returned from\n, as it will be true for as long as our mutation is running. To disable the form\nitself, all you need to do is to disable the primary submit button:\n\n```\n\nCopydisabled-submit: copy code to clipboard\n\n```\n\n### Invalidate and reset after mutation\n\nIf you do not redirect to a different page right after the form submission, it\nmight be a good idea to reset the form the invalidation has completed. As\ndescribed in , you'd likely want to do that in the callback of . This also works\nbest if you keep state seperated, as you only need to reset to in order for the\nserver state to be picked up again:\n\n```\n\nCopyreset-form: copy code to clipboard\n\n// ‚úÖ return Promise from invalidation\n\n// so that it will be awaited\n\n// ‚úÖ reset client state back to undefined\n\n```\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/react-query-fa-qs\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with MongoDB Atlas, the leading developer data\nplatform](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8268/0194f711-d91a-79c2-bd96-5f2504810472/>)\n\nI have been answering of questions over the last 18 months regarding React\nQuery. Being involved in the community and answering questions was what got me\ninto open-source in the first place, and it was also a big factor for writing\nthis React Query related series of articles.\n\nI'm still excited to answer questions, especially if they are well formulated\nand of the non-standard kind. Please see my post if you don't know what I mean\nor want to know what makes a question a good question.\n\nHowever, I have also seen a couple of repetitive questions that are mostly\nstraight-forward for me to answer, but still require a bit of effort to get into\nwriting. That's what this article is mainly about: To give myself yet another\nresource to point people towards when I see those questions again.\n\nWithout further ado, here are the top questions and my two cents on them:\n\n## How can I pass parameters to refetch?\n\nThe short answer is still: you cannot. But there's a very good reason for that.\nEvery time you that's what you want, you usually don't.\n\nMostly, code that wants to refetch with parameters looks something like this:\n\n```\n\nCopyrefetch-with-parameters: copy code to clipboard\n\n// üö® this is not how it works\n\n```\n\nParameters or Variables are dependencies to your query. In the above code, we\ndefine a QueryKey , so whatever we fetch will be stored under that key. If we\nwere to refetch with a id, it would still write to the same place in the cache,\nbecause the key stays the same. So id 2 would then overwrite data for id 1. If\nyou were to switch back to id 1, that data would be gone.\n\nCaching different responses under different query keys is one of React Query's\ngreatest strengths. The hypothetical \"refetch-with-parameters\" api would take\nthat feature away. This is why is only meant to replay the request with the same\nvariables. So in essence, you don't really want a : You want a for a different\nid!\n\nTo use React Query effectively, you have to embrace the declarative approach:\nThe query key defines all dependencies that the query function needs to fetch\ndata. If you stick to that, all you have to do to get refetches is to update the\ndependency. A more realistic example would look like this:\n\n```\n\nCopydynamic-query-key: copy code to clipboard\n\n// ‚úÖ set id without explicitly refetching\n\n```\n\nwill re-render the component, React Query will pick up the new key and start\nfetching for that key. It will also cache it separately from id 1.\n\nThe declarative approach also makes sure that no matter where or how you update\nthe id, your query data will always be \"in sync\" with it. So your thinking goes\nfrom: \"If I click that button, I want to refetch\" towards: \"I always want to see\ndata for the current id\".\n\nYou also don't have to store that id in - it can be done in any way to store\nclient side state (, , ...). In the above example, the URL would be a good place\nto store the id, too:\n\n```\n\nCopyurl-state: copy code to clipboard\n\n// ‚úÖ change url, make useParams pick it up\n\n```\n\nThe best part about this approach is that you don't have to manage state, that\nyou get sharable urls and that the browser back button will also just work for\nyour users to navigate between items.\n\nYou might notice that switching query keys will put your query into hard loading\nstate again. That is expected, because we change keys and there is no data for\nthat key yet.\n\nThere are a bunch of ways to ease the transition, like setting a for that key or\ndata for the new key ahead of time. A nice approach to tackle this problem is to\ninstruct the query to keep previous data:\n\n```\n\nCopykeep-previous-data: copy code to clipboard\n\n```\n\nWith this setting, React Query will still show data for id 1 while data for id 2\nis being fetched. Additionally, the flag on the query result will be set to\ntrue, so that you can act accordingly in the UI. Maybe you want to show a\nbackground loading spinner in addition to the data, or you'd like to add opacity\nto the shown data, indicating that it's stale. That is totally up to you - React\nQuery just gives you the means to do that. üôå\n\n## Why are updates not shown?\n\nWhen interacting with the Query Cache directly, be that because you want to\nperform an [update from a mutation\nresponse](https://tkdodo.eu/blog/<https:/react-\nquery.tanstack.com/guides/updates-from-mutation-responses>) or because you want\nto , I sometimes get reports that the updates are not reflected on the screen,\nor that it simply \"doesn't work\". If that's the case, it mostly boils down to\none of two issues:\n\n### 1: Query Keys are not matching\n\nQuery Keys are hashed deterministically, so you don't have to keep referential\nstability or object key order in mind. However, when you call , the key must\nstill match the existing key fully. As an example, those two keys do not match:\n\n```\n\nCopynon-matching-keys: copy code to clipboard\n\n```\n\nThe second value of the key array is a in the first example and a in the second.\nThis can happen if you usually work with numbers, but get a string if you read\nfrom the URL with .\n\nThe React Query Devtools are your best friend in this case, as you can clearly\nsee which keys exist and which keys are currently fetching. Keep an eye on those\npesky details though!\n\nI recommend using and to help with that problem.\n\n### 2: The QueryClient is not stable\n\nIn most examples, we create the queryClient the component, which makes it\nreferentially stable:\n\n```\n\nCopystandard-example: copy code to clipboard\n\n// ‚úÖ created outside of the App\n\n```\n\nThe holds the , so if you create a new client, you also get a new cache, which\nwill be empty. If you move the client creation into the component, and your\ncomponent re-renders for some other reason (e.g. a route change), your cache\nwill be thrown away:\n\n```\n\nCopyunstable-query-client: copy code to clipboard\n\n// üö® this is not good\n\n```\n\nIf you have to create your client inside the , make sure that it is\nreferentially stable by using an instance ref or React state:\n\n```\n\nCopystable-query-client: copy code to clipboard\n\n// ‚úÖ this is stable\n\n```\n\nI do have a separate blog post on that topic: .\n\n... if I can just as well import the client?\n\nThe puts the created into React Context to distribute it throughout your app.\nYou can best read it with . This does not create any extra subscriptions and\nwill not cause any additional re-renders (if the client is stable - see above) -\nit just avoids having to pass the client down as a prop.\n\nAlternatively, you could export the client and just import it wherever you need\nto:\n\n```\n\nCopyexported-query-client: copy code to clipboard\n\n// ‚¨áÔ∏è exported so that we can import it\n\n```\n\nHere are a couple of reasons why using the hook is preferred:\n\n### 1: useQuery uses the hook too\n\nWhen you call , we call under the hood. This will look up the nearest client in\nReact Context. Not a big deal, but if you ever get into the situation where the\nclient you import is different from the one in context you'll have a hard to\ntrace bug that could be avoided.\n\n### 2: It decouples your app from the client\n\nThe client you define in your is your production client. It might have some\ndefault settings that work well in production. However, in testing, it might\nmake sense to use different default values. One example is during testing,\nbecause testing erroneous queries might time out the test otherwise.\n\nA big advantage of React Context when used as a dependency injection mechanism\nis that it decouples your app from its dependencies. just expects any client to\nbe in the tree above - not a specific client. You'll lose that advantage if you\nimport the production client directly.\n\n### 3: You sometimes can't export\n\nIt is sometimes necessary to create the inside the App component (as shown\nabove). One example is when using server side rendering, because you want to\navoid having multiple users share the same client.\n\nThe same is true when you work with microfrontends - Apps should be isolated. If\nyou create the client outside the App, then use the same App twice on the same\npage, they'll share a client.\n\nLastly, if you want to use other hooks in the default values of the , you also\nneed to create it inside the App. Consider a global error handler that wants to\nshow a toast for every failing mutation:\n\n```\n\nCopyuse-other-hooks: copy code to clipboard\n\n// ‚úÖ we couldn't useToast outside of the App\n\n// ‚¨áÔ∏è but we need it here\n\n```\n\nSo if you create your like that, there is no way that you can just export it and\nimport it in your App.\n\nMy best guess on why you would want to export the client is if you're working\nwith a legacy class component that needs to do some query invalidation - and you\ncan't use hooks there. If that is the case, and you can't refactor to a\nfunctional component easily, consider creating a render props version:\n\n```\n\nCopyuseQueryClient-render-props: copy code to clipboard\n\n```\n\n```\n\nCopyusage: copy code to clipboard\n\n```\n\nAnd by the way, you can do the same thing for useQuery, or any other hook for\nthat matter:\n\n```\n\nCopyuseQuery-render-props: copy code to clipboard\n\n```\n\n```\n\nCopyusage: copy code to clipboard\n\n// üôå return jsx here\n\n```\n\n## Why do I not get errors ?\n\nIf your network request fails, you'd ideally want your query to go to the state.\nIf that doesn't happen, and you still see a successful query instead, that means\nthat your did not return a failed Promise.\n\nRemember: React Query doesn't know (or care) about status codes or network\nrequests at all. It needs a resolved or rejected Promise that the needs to\nprovide.\n\nIf React Query sees a rejected Promise, it can potentially start retries, pause\nqueries if you are offline and eventually put the query into the error state, so\nit's quite an important thing to get right.\n\nLuckily, many data fetching libraries like or transform erroneous status codes\nlike 4xx or 5xx into failed Promises, so if your network request fails, your\nquery fails too. The notable exception is the built-in , which will only give\nyou a failed Promise if the request failed due to a network error.\n\nThis is of course , but it's still a stumbling block if you've missed this.\n\n```\n\nCopywrong-fetch-api-example: copy code to clipboard\n\n// üö® 4xx or 5xx are not treated as errors\n\n```\n\nTo overcome this, you need to check if the response was and transform it into a\nrejected Promise if it wasn't:\n\n```\n\nCopycorrect-fetch-api-example: copy code to clipboard\n\n// ‚úÖ transforms 4xx and 5xx into failed Promises\n\n'Network response was not ok'\n\n```\n\nThe second reason I've seen a lot is that errors are caught inside the for\nlogging purposes. If you do that without re-throwing the error, you will again\nreturn a successful Promise implicitly:\n\n```\n\nCopywrong-logging-example: copy code to clipboard\n\n// üö® here, an \"empty\" Promise<void> is returned\n\n```\n\nIf you want to do this, remember to re-throw the error:\n\n```\n\nCopycorrect-logging-example: copy code to clipboard\n\n// ‚úÖ here, a failed Promise is returned\n\n```\n\nAn alternative and not so verbose way to handle errors is to use the callback of\nthe QueryCache. You can read more about different ways to handle errors in [#11:\nReact Query Error Handling](https://tkdodo.eu/blog/<react-query-error-\nhandling>).\n\nFrom time to time, I get bug reports that the isn't called even though it should\nbe. When that happens, the most likely reason is the use of together with :\n\n```\n\nCopyinitialData-and-staleTime: copy code to clipboard\n\n```\n\nThe thing is that is taken into account whenever a new cache entry is created,\nand that data is put into the cache. Once data is in the cache, React Query\ndoesn't care (and actually doesn't know) where it came from. Could be from the ,\ncould be because you called manually, or because of .\n\nCombined with the setting, that will now be seen as for the next 5 seconds. So\nthe \"mount\" of this instance will trigger a background refetch. Why should it -\nwe have fresh data (an empty array) in the cache. This is especially tricky to\nsee if is applied globally, and not itself.\n\nThe key takeaway here is that should only be used if you have \"real\" data\nsynchronously available - data that you'd happily cache for your users. The\nempty array is probably more of a \"fallback\" that you'd like to show until real\ndata has been fetched. For that use-case, is better:\n\n```\n\nCopyplaceholderData-and-staleTime: copy code to clipboard\n\n```\n\nSince is never cached, you'll always get a background refetch. You can read more\nabout the differences between and .\n\nAnother fix (more of a workaround really) is to specify that your is from the\nbeginning. Per default, React Query uses when it puts into the cache. However,\nwe can customize this with . I found that setting this to (or any time in the\npast really) works well to trigger a background update, too:\n\n```\n\nCopyinitialDataUpdatedAt: copy code to clipboard\n\n```\n\nAnother situation where this behaviour is hard to spot is when dynamic Query\nKeys are used, e.g. for paginated queries:\n\n```\n\nCopypaginated-queries: copy code to clipboard\n\n```\n\nYou might've wanted to express that only the Query with would get the into the\ncache, and that the is invoked when the goes from to .\n\nHowever, that's not the case. A Query with a different QueryKey is a completely\nnew Query in the cache. It has no knowledge about your component or that you've\nused a different QueryKey before. That means will be applied for it too (if it's\nspecified like above).\n\nWhat we have to do is to be quite specific about which Query should get the :\n\n```\n\nCopycorrect-initial-data: copy code to clipboard\n\n```\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# React Query meets React Router\nURL: https://tkdodo.eu/blog/react-query-meets-react-router\n\n# React Query meets React Router\n\n‚Äî , , , , ‚Äî\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * **#16: React Query meets React Router**\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Simplified data ingestion for\ndevelopers](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8327/0194f711-f2ff-7230-b2ba-49aaab073957/>)\n\nis changing the game, and they are bringing their data fetching concepts\n(loaders and actions) to purely client side rendered applications with . I went\nthrough their great that shows the concept very well and demonstrates how you\ncan quickly build a small, but feature-rich app.\n\nWith React Router coming into the data fetching game, it is naturally\ninteresting to understand how this competes or correlates with existing data\nfetching and caching libraries like React Query. So let me spoil it right here:\n\nThey are a match made in heaven\n\n## A router that fetches data\n\nTo recap: React Router will allow you to define on each route, which will be\ncalled when the route is visited. In the route component itself, you can to get\naccess to that data. Updating data is as simple as submitting a , which will\ncall an function. Actions invalidate all active loaders, so you'll automagically\nsee updated data on your screen.\n\nIf this sounds very similar to and - you are right, it does. So the questions\nthat have been popping up after the announcement of are:\n\n  * Would we still want React Query now that we can fetch in the route?\n  * If we already use React Query, do we want to (and how can we) leverage the new React Router features?\n\nTo me, the answers to both questions are clearly: YES. As from the remix team\nhas put it: \"React Router is not a cache\":\n\n[Nah, React Router is not a cache.Browsers have this built in with HTTP and\nlibraries like React Query have this job nailed down.React Router is about\n*when*, data caching libs are about\n*what*.](https://tkdodo.eu/blog/<https:/x.com/ryanflorence/status/1561731634419773447>)\n\nFetching \"as early as possible\" is an important concept to provide the best\npossible user experience. Full Stack frameworks like or Remix move this step to\nthe server, because that is the earliest entry point. With client rendered\napplications, we have no such luxury.\n\nWhat we are usually doing is fetching on component mount - when data is first\nneeded. That is not great, as it will lead to a loading spinner visible to the\nuser for as long as we are initially fetching. can help, but only for subsequent\nnavigations, and you need to manually set it up for every way to navigate to a\nroute.\n\nThe router however is the first component that always knows which page you are\ntrying to visit, and because it now has loaders, it can know which data those\npages need to render. This is great for the first page visit - but loaders are\ncalled on page visit. And as the router has no cache, it will hit the server\nagain, unless we do something about it.\n\nAs an example (yes, this is from the tutorial mentioned before. Credits go to\nRyan Florence), suppose you have a list of contacts. If you click on one of\nthem, you show the contact details:\n\n```\n\nCopysrc/routes/contact.jsx: copy code to clipboard\n\n// ‚¨áÔ∏è this is the loader for the detail route\n\n// ‚¨áÔ∏è this gives you data from the loader\n\n```\n\n```\n\nCopysrc/main.jsx: copy code to clipboard\n\n// ‚¨áÔ∏è this is the loader for the detail route\n\n```\n\nIf you navigate to , data for that contact will be fetched the component is\nrendered. By the time we want to show the Contact, will have data readily\navailable. This is awesome as it not only improves the user experience, but look\nat that developer experience of co-located data fetching and rendering! I love\nit. ü•∞\n\nThe big drawback of not having a cache shows when you go to Contact 2 and then\nback to Contact 1 again. If you are used to React Query, you will know that data\nfor Contact 1 is cached already, so we can show it instantly and kick of a\nbackground refetch if data is considered stale. With the loader approach, we\nwill have to fetch that data again (and wait for it to finish fetching!), even\nthough we have already fetched it before.\n\nAnd that is exactly where React Query comes in.\n\nWhat if we can use the loader to pre-fill the React Query Cache, but still in\nthe component to get all the React Query goodies like and showing stale data\ninstantly? To me, this sounds like the best of both worlds. The router is\nresponsible for fetching data early (if we don't have it), and React Query is\nresponsible for caching and keeping the data fresh.\n\nLet's try to move the example in that direction:\n\n```\n\nCopysrc/routes/contacts.jsx: copy code to clipboard\n\n// ‚¨áÔ∏è define your query\n\n// ‚¨áÔ∏è needs access to queryClient\n\n// ‚¨áÔ∏è return data or fetch it\n\n// ‚¨áÔ∏è useQuery as per usual\n\n```\n\n```\n\nCopysrc/main.jsx: copy code to clipboard\n\n// ‚¨áÔ∏è pass the queryClient to the route\n\n```\n\nThere are a couple of things going on here, so let's break it down:\n\n### The loader needs access to the QueryClient.\n\nThe loader is not a hook, so we can't . Importing the QueryClient directly is\nsomething that , so passing it explicitly seems like the best alternative.\n\nWe want the loader to wait for our data to be ready and return it to get a good\nexperience on the first loads. We also want errors to be thrown to the , so is\nthe best option. Note that doesn't return anything and catches errors internally\n(otherwise, they are equivalent).\n\ndoes the trick for returning any data we have in the cache, even if it's stale.\nThis ensures that recurring visits to a page will show data immediately. Only if\nreturns (meaning nothing is in the cache), we'll actually do the fetch.\n\nAn alternative approach would be to set a for :\n\n```\n\nCopyalternative-loader: copy code to clipboard\n\n```\n\nSetting the to two minutes tells to resolve data immediately if it's available\nand not older than two minutes, otherwise, it will go and fetch it. If you are\nfine with stale data being shown in the component, this is a good alternative.\n\nSetting to is almost equivalent to the approach, except that manual query\ninvalidation takes precedence over . So I like the approach a bit better, even\nif it is slightly more code.\n\n‚Äã: As of , you can use the built-in method to achieve the same thing. It is\nliterally implemented with , but it's a common enough use-case for the library\nto have it out of the box.\n\nWith this, it is guaranteed that calling in the component will have some data\navailable, just like calling would. However, TypeScript has no way of knowing\nthis - the data returned is of type .\n\nThanks to and his to React Query v4, we can now exclude from the union if is\nprovided.\n\nAnd where would we get from? of course! We can even infer the type from the\nloader function:\n\n```\n\nCopyinitial-data: copy code to clipboard\n\n```\n\nIt's a bit much to write because our loader is a function that returns a\nfunction, but we can tuck that away in a single util. Also, it seems that right\nnow, using type assertions is the only way to narrow the return type of . ü§∑‚Äç‚ôÇÔ∏è\nBut it will nicely narrow the type of the result, which is what we want. üôå\n\nThe next piece of the puzzle involves query invalidation. Here is how an action\nwould look without React Query, straight from the tutorial (yes, this is all it\ntakes to perform an update):\n\n```\n\nCopysrc/routes/edit.jsx: copy code to clipboard\n\n```\n\nActions invalidate loaders, but because we've set up our loaders to always\nreturn data from the cache, we won't see any updates unless we somehow\ninvalidate the cache. It's just one line of code really:\n\n```\n\nCopysrc/routes/edit.jsx: copy code to clipboard\n\n```\n\nThe will make sure that our list and our detail view will get new data in the\ncache by the time the action is finished, and we're redirecting back to the\ndetail view.\n\nHowever, this will make our action function take longer and block the\ntransition. Would we not be able to trigger the invalidation, then redirect to\nthe detail view, show the stale data and then let it update in the background\nonce the new data is available? Of course we can: Just leave out the keyword:\n\n```\n\nCopysrc/routes/edit.jsx: copy code to clipboard\n\n```\n\nAwait literally becomes a lever you can pull in either direction (This analogy\nis based on Ryan's great talk . Please watch it if you haven't already):\n\n  * Is it important to transition back to the detail view as soon as possible? Do not await.\n  * Is it important to avoid potential layout shifts when showing stale data, or do you want to keep the action pending until you have all new data? Use await.\n\nIf multiple invalidations are involved, you can also mix and match the two\napproaches to wait for important refetches, but let less important ones be done\nin the background.\n\nI'm very excited about the new React Router release. It's a great step forward\nto enable all applications to trigger fetches as early as possible. However, it\nis not a replacement for caching - so go ahead and combine React Router with\nReact Query to get the best of both worlds. üöÄ\n\nIf you want to explore this topic some more, I've implemented the app from the\ntutorial and added React Query on top of it - you can find it in [the examples\nof the official\ndocs](https://tkdodo.eu/blog/<https:/tanstack.com/query/latest/docs/framework/react/examples/react-\nrouter>).\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/seeding-the-query-cache\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * **#17: Seeding the Query Cache**\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8272/0194f712-097f-7741-a747-6d47d396aefc/>)\n\nA new RFC about [first class support for\nPromises](https://tkdodo.eu/blog/<https:/github.com/reactjs/rfcs/pull/229>) has\nbeen released last week, and it got some talk going about how this would\nintroduce fetch waterfalls if used incorrectly. So what are fetch waterfalls\nexactly?\n\nA waterfall describes a situation where one request is made, and we wait for it\nto complete before firing another request.\n\nSometimes, this is unavoidable, because the first request contains information\nthat is needed to make the second request. We also refer to these as :\n\nIn many cases though, we can actually fetch all the data we need in parallel,\nbecause it is independent data:\n\nIn React Query, we can do that in two different ways:\n\n```\n\nCopyparallel-queries: copy code to clipboard\n\n// 1. Use useQuery twice\n\n// 2. Use the useQueries hook\n\n```\n\nIn both variants, React Query will kick off data fetching in parallel. So where\ndo waterfalls come in?\n\nAs described in the above linked RFC, suspense is a way to unwrap promises with\nReact. A defining trait of promises is that they can be in three different\nstates: , or .\n\nWhen rendering components, we are mostly interested in the success scenario.\nHandling loading and error states in each and every component can be tedious,\nand suspense is aimed at solving this problem.\n\nWhen a promise is , React will unmount the component tree and render a fallback\ndefined by a boundary component. In case of errors, the error is bubbled up to\nthe nearest .\n\nThis will decouple our components from handling those states, and we can focus\non the happy path. It almost acts like synchronous code that just a value from a\ncache. React Query offers a dedicated hook for that since v5:\n\n```\n\nCopyuseQuery-with-suspense: copy code to clipboard\n\n// üëì read data from cache\n\n// üéâ no need to handle loading or error states\n\n/* TypeScript knows data can't be undefined */\n\n// üöÄ Boundaries handle loading and error states\n\n```\n\nSo this is nice and all, but it can backfire when you use multiple queries in\nthe same component that have suspense turned on. Here is what happens:\n\n  * Component renders, tries to read the first query\n  * Sees that there is no data in the cache yet, so it suspends\n  * This unmounts the component tree, and renders the fallback\n  * When the fetch is finished, the component tree is remounted\n  * First query is now read successfully from the cache\n  * Component sees the second query, and tries to read it\n  * Second query has no data in the cache, so it suspends (again)\n\nThis will have pretty impactful implications on your application's performance,\nbecause you'll see that fallback for waaay longer than necessary.\n\nThe best way to circumvent this problem is to stick to one query per component,\nor to make sure that there is already data in the cache when the component tries\nto read it.\n\nThe earlier you initiate a fetch, the better, because the sooner it starts, the\nsooner it can finish. ü§ì\n\n  * If your architecture supports server side rendering - consider .\n  * If you have a router that supports loaders, consider .\n\nBut even if that's not the case, you can still use to initiate a fetch before\nthe component is rendered:\n\n```\n\nCopyprefetching: copy code to clipboard\n\n// ‚¨áÔ∏è initiate a fetch before the component renders\n\n```\n\nThe call to is executed as soon as your JavaScript bundle is evaluated. This\nworks very well if you do , because it means the code for a certain page will be\nlazily loaded and evaluated as soon as the user navigates to that page.\n\nThis means it will still be kicked off before the component renders. If you do\nthis for both queries in our example, you will get those parallel queries back\neven when using suspense.\n\nAs we can see, the query will still suspend until both are done fetching, but\nbecause we've triggered them in parallel, the waiting time is now drastically\nreduced.\n\n: doesn't support right now, but it might do in the future. If we add support,\nthe goal is to trigger all fetches in parallel to avoid those waterfalls.\n\nI don't know enough about the RFC yet to properly comment on it. A big part is\nstill missing, namely how the cache API will work. I do think it is a bit\nproblematic that the default behaviour will lead to waterfalls unless developers\nexplicitly seed the cache early on. I'm still pretty excited about it because it\nwill likely make internals of React Query easier to understand and maintain. It\nremains to be seen if it is something that will be used in userland a lot.\n\nAnother nice way to make sure that your cache is filled by the time it is read\nis to seed it from other parts of the cache. Oftentimes, if you render a detail\nview of an item, you will have data for that item readily available if you've\npreviously been on a list view that shows a list of items.\n\nThere are two common approaches to fill a detail cache with data from a list\ncache:\n\nThis is the one also described : When you try to render the detail view, you\nlook up the list cache for the item you want to render. If it is there, you use\nit as initial data for the detail query.\n\n```\n\nCopypull-approach: copy code to clipboard\n\n// ‚¨áÔ∏è look up the list cache for the item\n\n```\n\nIf the function returns , the query will proceed as normal and fetch the data\nfrom the server. And if something is found, it will be put into the cache\ndirectly.\n\nBe advised that if you have set, no further background refetch will occur, as\ninitialData is seen as . This might not be what you want if your list was last\nfetched twenty minutes ago.\n\nAs shown , we can additionally specify on our detail query. It will tell React\nQuery when the data we are passing in as was originally fetched, so it can\ndetermine staleness correctly. Conveniently, React Query also knows when the\nlist was last fetched, so we can just pass that in:\n\n```\n\nCopyinitialDataUpdatedAt: copy code to clipboard\n\n// ‚¨áÔ∏è get the last fetch time of the list\n\n```\n\nüü¢ seeds the cache \"just in time\" üî¥ needs more work to account for staleness\n\nAlternatively, you can create detail caches whenever you fetch the list query.\nThis has the advantage that staleness is automatically measured from when the\nlist was fetched, because, well, that's when we create the detail entry.\n\nHowever, there is no good callback to hook into when a query is fetched. The\nglobal callback on the cache itself might work, but it would be executed for\nevery query, so we'd have to narrow it down to the right query key.\n\nThe best way I've found to execute the push approach is to do it directly in the\n, after data has been fetched:\n\n```\n\nCopypush-approach: copy code to clipboard\n\n// ‚¨áÔ∏è create a detail cache for each item\n\n```\n\nThis would create a detail entry for each item in the list immediately. Since\nthere is no one interested in those queries at the moment, those would be seen\nas , which means they might be garbage collected after has elapsed (default: 15\nminutes).\n\nSo if you use the push approach, the detail entries you've created here might no\nlonger be available once the user actually navigates to the detail view. Also,\nif your list is long, you might be creating way too many entries that will never\nbe needed.\n\nüü¢ staleTime is automatically respected üü° there is no good callback üü° might\ncreate unnecessary cache entries üî¥ pushed data might be garbage collected too\nearly\n\nKeep in mind that both approaches only work well if the structure of your detail\nquery is exactly the same (or at least assignable to) the structure of the list\nquery. If the detail view has a mandatory field that doesn't exist in the list,\nseeding via is not a good idea. This is where comes in, and I've written a\ncomparison about the two in [#9: Placeholder and Initial Data in React\nQuery](https://tkdodo.eu/blog/<placeholder-and-initial-data-in-react-query>).\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/inside-react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Develop and launch modern apps with MongoDB Atlas, a resilient data\nplatform.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8269/0194f712-21d3-7810-ae02-5d2af8927d94/>)\n\nI've been asked a lot lately how React Query works internally. How does it know\nwhen to re-render? How does it de-duplicate things? How come it's framework-\nagnostic?\n\nThese are all very good questions - so let's take a look under the hood of our\nbeloved async state management library and analyze what really happens when you\ncall .\n\nTo understand the architecture, we have to start at the beginning:\n\nIt all starts with a . That's the class you create an instance of, likely at the\nstart of your application, and then make available everywhere via the :\n\n```\n\nCopyquery-client-provider: copy code to clipboard\n\n// ‚¨áÔ∏è this creates the client\n\n// ‚¨áÔ∏è this distributes the client\n\n```\n\nThe uses to distribute the throughout the entire application. The client itself\nis a stable value - it's created once (make sure you don't [inadvertently re-\ncreate it too often](https://tkdodo.eu/blog/<react-query-fa-qs#2-the-\nqueryclient-is-not-stable>)), so this is a perfect case for using Context. It\nwill make your app re-render - it just gives you access to this client via .\n\n### A vessel that holds the cache\n\nIt might not be well known, but the itself doesn't really do much. It's a\ncontainer for the and the , which are automatically created when you create a .\n\nIt also holds some defaults that you can set for all your queries and mutations,\nand it provides convenience methods to work with the caches. In most situations,\nyou will interact with the cache directly - you will access it through the .\n\nAlright, so the client lets us work with the cache - what is the cache?\n\nSimply put - the is an in-memory object where the keys are a stably serialized\nversion of your (called a ) and the values are an instance of the class.\n\nI think it's important to understand that React Query, per default, stores data\nin-memory and nowhere else. If you reload your browser page, the cache is gone.\nHave a look at the if you want to write the cache to an external storage like\nlocalstorage.\n\nThe cache has queries, and a is where most of the logic is happening. It not\nonly contains all the information about a query (its data, status field or meta\ninformation like when the last fetch happened), it also executes the query\nfunction and contains the retry, cancellation and de-duplication logic.\n\nIt has an internal to make sure we don't wind up in impossible states. For\nexample, if a query function should be triggered while we are already fetching,\nthat fetch can be de-duplicated. If a query is cancelled, it goes back to its\nprevious state.\n\nMost importantly, the query who's interested in the query data, and it can\ninform those about all changes.\n\nObservers are the glue between the and the components that want to use it. An is\ncreated when you call , and it is always subscribed to exactly one query. That's\nwhy you pass a to . üòâ\n\nThe does a bit more though - it's where most of the optimizations happen. The\nknows which properties of the a component is using, so it doesn't have to notify\nit of unrelated changes. As an example, if you only use the field, the component\ndoesn't have to re-render if is changing on a background refetch.\n\nEven more - each can have a option, where you can decide which parts of the\nfield you are interested in. I've written about this optimization before in [#2:\nReact Query Data Transformations](https://tkdodo.eu/blog/<react-query-data-\ntransformations#3-using-the-select-option>). Most of the timers, like ones for\nor interval fetching, also happen on the observer-level.\n\nA without an is called an query. It's still in the cache, but it's not being\nused by any component. If you take a look at the React Query Devtools, you will\nsee that inactive queries are greyed out. The number on the left side indicates\nthe number of that are subscribed to the query.\n\nPutting it all together, we can see that most of the logic lives inside the\nframework-agnostic Query Core: , , and are all there.\n\nThat's why it's fairly straightforward to create an adapter for a new framework.\nYou basically need a way to create an , subscribe to it, and re-render your\ncomponent if the is notified. The adapters for and each have around 100 lines of\ncode only.\n\nLastly, let's look at the flow from another angle - starting with a component:\n\n  * the component , it calls , which creates an .\n  * that the , which lives in the .\n  * that subscription might trigger the creation of the (if it doesn't yet exist), or it might trigger a background refetch if data is deemed stale.\n  * starting a fetch changes the state of the , so the will be informed about that.\n  * The will then run some optimizations and potentially notify the component about the update, which can then render the new state.\n  * after the has finished running, it will inform the about that as well.\n\nPlease note that this is of many potential flows. Ideally, data would be in the\ncache already when the component mounts - you can read more about that in [#17:\nSeeding the Query Cache](https://tkdodo.eu/blog/<seeding-the-query-cache>).\n\nWhat's the same for all flows is that most of the logic happens outside of React\n(or Solid or Vue), and that every update from the state machine is propagated to\nthe , who then decides if the component should also be informed.\n\nI hope it's now a bit clearer how React Query works internally. As always, feel\nfree to reach out to me on if you have any questions, or just leave a comment\nbelow. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/type-safe-react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Develop and launch modern apps with MongoDB Atlas, a resilient data\nplatform.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8269/0194f712-3611-7310-b5df-\nae714d2476e9/>)\n\nI think we can all agree that using TypeScript is a good idea. Who doesn't like\ntype-safety? It's a great way to catch bugs early on, and it allows us to\noffload some complexity of our apps to the type definitions so that we don't\nhave to keep them in our heads forever.\n\nThe level of type-safety can drastically vary from project to project. After\nall, every valid JavaScript code be valid TypeScript code - depending on the TS\nsettings. And there is also a big difference between \"having types\" and \"being\ntype-safe\".\n\nTo truly leverage the power of TypeScript, there is one thing that you need\nabove all:\n\nWe need to be able to our type definitions. If we don't, our types become a mere\nsuggestion - we can't rely on them to be accurate. So we go above and beyond to\nmake sure we trust them:\n\n  * We enable the of TypeScript settings.\n  * We add to forbid the type as well as .\n  * We point out all type assertions in code reviews.\n\nAnd still - we are probably lying. A LOT. Even if we adhere to all the above\nthings.\n\nGenerics are essential in TypeScript. As soon as you want to implement something\nremotely complex, you will have to reach for them - especially when you're\nwriting a reusable library.\n\nHowever, as a user of a library, you ideally shouldn't need to care about their\nGenerics. They are an implementation detail. So whenever you provide a generic\n\"manually\" to a function via the angle brackets, it's kinda bad for one of two\nreasons:\n\nIt's either unnecessary, or you're lying to yourself.\n\nAngle brackets makes your code look \"more complex\" than it has to be. As an\nexample, let's look at how is often written:\n\n```\n\nCopyuseQuery-with-angle-brackets: copy code to clipboard\n\n//  ^?(property) data: Todo | undefined\n\n```\n\nThe main problem here is that has four generics. By providing only one of them\nmanually, the other three fall back to their default values. You can read about\nwhy that's bad in [#6: React Query and\nTypeScript](https://tkdodo.eu/blog/<react-query-and-type-script#the-four-\ngenerics>).\n\nJust to be on the same page - returns (just like would, but does this slightly\nbetter by giving us back per default). It doesn't know what the endpoint will\nreturn. And because we don't want our property to be as well, we have to\n\"override\" the inferred generic by providing it manually. Or do we?\n\nThe better way is to type the function itself:\n\n```\n\nCopytyped-fetchTodo: copy code to clipboard\n\n// ‚úÖ typing the return value of fetchTodo\n\n// ‚úÖ no generics on useQuery\n\n// üôå types are still properly inferred\n\n//  ^?(property) data: Todo | undefined\n\n```\n\nNow with this, React Query can properly infer what data will be from the result\nof the . No need for manual generics. If the to is sufficiently typed, you will\nhave to add angle brackets to it. üéâ\n\nAlternatively, we can also tell our data fetching layer, in this case , what the\nexpected type is by providing the Generics via angle brackets there:\n\n```\n\nCopyproviding-generics: copy code to clipboard\n\n```\n\nNow we don't even have to type the function if we don't want to because type\ninference will again work for us here. Those generics are not unnecessary per\nse, but they are a lie because they violate the golden rule of Generics.\n\n### The golden rule of Generics\n\nI learned this rule from great book . It basically states:\n\nFor a Generic to be useful, it must appear at least twice.\n\nThe so called \"return-only\" generics are nothing more than a type assertion in\ndisguise. The (slightly simplified) type signature for reads:\n\n```\n\nCopyaxios-get-type-signature: copy code to clipboard\n\n```\n\nThe Type only appears in one place - the return type. So it's a lie! We could've\njust as well written:\n\n```\n\nCopyexplicit-type-assertion: copy code to clipboard\n\n```\n\nAt least this type assertion () is explicit and not hidden. It shows that we are\nbypassing the compiler, that we are getting something unsafe and trying to turn\nit into something we can trust.\n\nAnd now we are back to trust. How can we trust that what we're getting over the\nwire is in fact of a certain type? We cannot, and maybe that's okay.\n\nI used to refer to this situation as a \"trusted boundary\". We trust that what\nthe backend returns is what we have agreed upon. If it's not, this isn't fault -\nit's the fault of the backend team.\n\nOf course, the customer doesn't care. All they see is \"cannot read property name\nof undefined\" or something similar. Frontend devs will be called into the\nescalation, and it will take us quite a bit of time to actually figure out that\nwe're not getting the right shape of data over the wire, because the error will\nappear in a completely different place.\n\nSo is there something that we can do to give us trust?\n\nis a beautiful validation library that lets you define a schema you can validate\nagainst . On top of that, it infers the type of the validated data directly from\nthe schema.\n\nThis basically means that instead of writing a type definition and then\nasserting that something is that type, we write a schema and validate that the\ninput conforms to that schema - at which point it that type.\n\nI first heard about zod when working with forms. It makes total sense to\nvalidate user input. As a nice side effect, the input will also be typed\ncorrectly after the validation. But we can not only validate user input - we can\nvalidate anything. Url params for example. Or network responses...\n\n```\n\nCopyparsing-with-zod: copy code to clipboard\n\n// üëÄ define the schema\n\n// üéâ parse against the schema\n\n```\n\nThis isn't even more code than before. We've basically exchanged two things:\n\n  * the manual type definition of the type with the definition.\n  * the type assertion with the schema parsing.\n\nThis plays so well together with React Query because throws a descriptive if\nsomething went wrong, which will make React Query go into state - just as if the\nnetwork call itself failed. And from the client perspective - it did fail,\nbecause it didn't return the expected structure. Now we have an state that we\nneed to handle anyway, and there will be no surprises for our users.\n\nIt also goes nicely with another guideline of mine:\n\nThe more your TypeScript code looks like JavaScript, the better.\n\nApart from , there isn't a single thing that differentiates this TS code from\nJS. There is no added TypeScript complexity - we just get the benefits of type-\nsafety. Type inference \"flows\" through our code like a hot knife through butter.\nü§§\n\nSchema parsing is a great concept to be aware of, but it's not for free. For\nstarters, your schemas should be as resilient as you want them to be. If it\ndoesn't matter that an optional property is or at runtime, you might create a\nmiserable user experience if you fail the query because of something like that.\nSo design your schemas resiliently.\n\nAlso, parsing does come with an overhead, as data must be analyzed at runtime to\nsee if it fits the required structure. So it might not make sense to apply this\ntechnique everywhere.\n\nYou might have noticed that suffers from the same problem: It contains a return-\nonly generic, and it will default to if you don't provide it.\n\n```\n\nCopygetQueryData-generic: copy code to clipboard\n\n//  ^? const todo: unknown\n\n//  ^? const todo: Todo | undefined\n\n```\n\nSince React Query cannot know what you put into the (as there is no up-front\ndefined overall schema), this is the best we can do. Of course, you can also\nparse the result of with a schema, but this isn't really necessary if you've\nvalidated the cached data before. Also, direct interactions with the should be\ndone sparingly.\n\nTools on top of React Query, like , do a great job at alleviating the pain, but\nthey can only go so far and basically hide the lie a bit more for you.\n\nWhile there isn't a lot more that React Query can do for us in this regard,\nthere are other tools that can. If you are in control over both your frontend\nand backend, and if they even live in the same monorepo together, consider using\ntools like or . They both build on top of React Query for the client-side data\nfetching solution, but they both have what it takes to become truly type-safe:\nan upfront API / router definition.\n\nWith that, types on the frontend can be inferred from whatever the backend\nproduces - without a chance of being wrong. They also both use for defining the\nschema (tRPC is validation library agnostic, but is the most popular), so\nlearning how to work with could definitely go on your list to learn for 2023. üéä\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# You Might Not Need React Query\nURL: https://tkdodo.eu/blog/you-might-not-need-react-query\n\n# You Might Not Need React Query\n\n‚Äî , , , , ‚Äî\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * **#20: You Might Not Need React Query**\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Find out how Algolia AI Search can instantly and precisely understand your\nuser's\nintent.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8293/0194f712-4a03-7dc3-9268-70eab95e2d38/>)\n\nWill kill React Query? This is probably the question I'm getting asked the most\nfor the past couple of months. And the thing is: I have no good answer.\nRemember: Like most devs in this industry, I'm also just making things up as we\ngo. If you expect me to have a grand plan for everything, I'm here to\ndisappoint. I'm just as curious as you are how things will turn out in the end.\nüòÖ\n\n[Not gonna lie that (as a maintainer of a library in the data fetching space)\nI'm feeling mostly afraid of server components and suspense.\"How will this work\nwith react-query\" is a good question. It feels like I'm supposed to have an\nanswer but I don't. Huge imposter syndrome\nrn](https://tkdodo.eu/blog/<https:/x.com/TkDodo/status/1585204181651988481>)\n\nThat said, I now had some time to look at this topic a bit closer, and I also\ndiscussed this with some folks who know way more about the topic than I do. I\nnow feel confident enough to give you on the topic. But that's all that is: , so\ntake it with a grain of salt.\n\nEvery tool that we're using should help us solve a problem that we're having.\nTraditionally, React was pretty un-opinionated on how to do data fetching in\nyour application. It literally didn't care - here's and do with it what you\nwant.\n\nThis is the time libraries like or were born in. They filled a pretty big gap\nand were quickly adopted because of their great DX and improvements they brought\nfor users as well. falls into a similar category - solving the need for routing\nwhen your \"view\" library has nothing to offer out of the box.\n\nWhen Server Side Rendering became a thing, we were mostly focussed on pre-\nrendering html on the server to speed up the initial page load. After that, our\napp behaves like a full SPA - client side page navigations and all. In this\nworld, React Query also plays an important role: You can move initial data\nfetching to the server, and then hydrate the fetch results on the client. This\nprovides a good way to as early as possible - on the server.\n\nTimes are evolving, things get better. Even though it might look like things are\noscillating back and forth, they are, in fact, moving forward:\n\n[i'm sure can do better but this is what i see in my head every time i see \"devs\njust go back and forth in endless cycles\"\ncomments](https://tkdodo.eu/blog/<https:/x.com/swyx/status/1260019961868677121>)\n\nReact is still just a library to render components, but with Server Components,\nit now offers a new application architecture where you can render them ahead of\ntime, on the server. This could be during build time, or at runtime, where they\nallow access to data without building an API that needs to be queried from the\nclient:\n\n```\n\nCopyserver-component: copy code to clipboard\n\n```\n\nIt still blows my mind that using inside a React Component , and it's exciting\nto see frameworks picking up the problem and offering first class solutions to\nthem. This changes things dramatically for applications that are adopting this\narchitecture. React Query is, first and foremost, a library to manage\nasynchronous state on the client. If your data fetching happens on the server\nexclusively - why would you need it?\n\n### You Might Not Need It\n\nAnd the answer is: You probably don't. If you're starting a new application, and\nyou're using a mature framework like or that has a good story around data\nfetching and mutations, you probably don't need React Query.\n\nAnd that's totally fine. I'm not here to tell you to use React Query in every\npossible situation, just because I happen to maintain it. If you decide to use\nit, it should be because it helps you solve a problem.\n\nThere is still a lot of space to integrate React Query into this new world of\nServer Components. For one, most projects won't start on a green field. There\nare tons of applications out there that have been built over the years, and\nwhile you can incrementally adopt the directory, leveraging Server Components\nrequires some sort of re-architecture.\n\nFor this transitioning period, React Query integrates very well with the\ndirectory and Server Components. You can move some components to fetch on the\nserver only, or you can use Server Components to prefetch your cache and pass\nthe result to a client component, where you . It doesn't have to be all-or-\nnothing. The already have a good guide for this integration, and I will likely\nfollow this up with another blog post on things to look out for.\n\nThis hybrid approach can be especially beneficial if you are hitting a use-case\nthat isn't (yet) well supported by Server Components.\n\nAs an example, you might want to render an Infinite Scrolling List, where you\npre-fetch the first page on the server, but you want to fetch more pages on the\nclient as the user scrolls towards the end. Or you might have the requirement to\nhave your app work as well. Or maybe you just like the user experience of always\nseeing fresh data, even without an explicit user interaction (think: interval\nfetching or all the smart auto-refetches you get from React Query).\n\nReact Query has a great story around all these situations, so there are\ndefinitely cases where combining it with Server Components makes sense. However,\nif you've used React Query primarily to fetch some data and display it to the\nuser, I think Server Components will have you nicely covered there as well. And\nonce the mutation story () become an established pattern, you might not even\nneed it for updating data.\n\nI think it's also fair to say that not everybody will be adopting Server\nComponents, for various reasons. Maybe your backend is not written in nodeJs,\nand it's fine that your frontend is an SPA without a dedicated server. Maybe\nyou're building a mobile app with React Native. If you're a TanStack Query user,\nyou might not even use React at all.\n\nFurther, you can use React Query for things data fetching. Have a look at the\nreplies to this tweet to get some inspiration:\n\n[What are some things that you use TanStack Query for that is _not_ data\nfetching? Curious to know what other use-cases you all have\nüòÑ](https://tkdodo.eu/blog/<https:/x.com/TkDodo/status/1616490384305311745>)\n\nAll of these are perfectly fine use-cases to choose Query as your async state\nmanager on the client. But if you are opting to go with a framework that has\nbuilt-in, first class support for this - please use that! I mean, why would you\nuse remix and not fetch data in their loaders? ü§∑‚Äç‚ôÇÔ∏è\n\nSo, my prediction is that there will still be plenty of usages outside - and\neven combined with - React Server Components for TanStack Query. The current\nnarrative is all about RSC though, and that's fine. It's a new, shiny piece of\ntech that everybody is excited to try out.\n\nBut it's still quite early, bleeding edge tech. In order to use them, you have\nto tightly integrate with a given framework, a router and a bundler. It also\nmeans you need to have the infrastructure to handle the additional server load.\nI kind of keep repeating myself, but:\n\nthere is no free lunch; everything is a tradeoff.\n\nSo, I would not feel obliged to move everything over to Server Components\nimmediately. As a Next.js user myself, I'm excited to move our app over to the\ndirectory - mainly to benefit from nested routes. And I'll definitely move some\nof the more static data fetching (e.g. where we have ) over to Server\nComponents.\n\nBut reports of React Query's death are greatly exaggerated.\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/thinking-in-react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * **#21: Thinking in React Query**\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with MongoDB Atlas, the leading developer data\nplatform](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8268/0194f712-5c53-7dc0-8261-f1a77bcd4b97/>)\n\nToday's article comes in a different form: it's the slides + transcript from a\ntalk I recently gave at a meetup in Vienna, as well as on the remote day of .\nYou can swipe left or right or use the arrow buttons / arrow keys to switch\nbetween the slides. You can also find the recording on . Enjoy!\n\nHello everyone üëã, thanks for being here with me today, where I want to talk\nabout...\n\nMost people don't know that there is a right and a wrong way to tie your shoes.\nBoth ways look very similar at first glance, but one knot is stable and the\nother loosens as you walk. It's a little difference that might change your life.\nStay tuned until the end where I'll show you that trick.\n\nWhen working with React Query, we might face similar situations, where a small\ntweak can make a huge difference.\n\nI discovered this when I started my open source journey back in 2020, where I\nwas mostly helping out by engaging with the community.\n\nI answered A LOT of questions on different platforms, which was a great way for\nme to get started in open source. Turns out, people are really happy and\ngrateful if you help them solve their problem, and I also learned a lot by\nhaving to look at situations I haven't encountered myself yet.\n\nWith that, I got to know React Query pretty well, and that's when I realized a\ncommon pattern among those questions. A lot of them showed an underlying\nmisconception of what React Query is or does, and would probably answer\nthemselves with a little shift in thinking.\n\nMy name is Dominik, and I'm a Software Engineer from Vienna. I go by the name\nTkDodo online almost everywhere, I work as a Frontend Tech Lead at Adverity, and\nI've also had the privilege to maintain the open source library React Query for\nthe past two years.\n\nSo today, what I really want to talk about is showing you 3 simple ways on how\nto approach react query with a better mindset. Similar to tying your shoes\ncorrectly, once you know it, it hopefully makes a lot of sense and is quite\nsimple to follow.\n\nSo let's take a look at what it takes to be \"Thinking in React Query\"\n\nThe first point might surprise you, but it's true: Even though it is often\ndescribed as \"the missing piece for data fetching in React\", React Query is NOT\na data fetching library. It doesn't do any data fetching for you, because if we\ntake a quick look\n\nat a standard react query example: we can see that we need to provide two things\nto :\n\nA unique where React Query will store the data for us,\n\nand a that will be executed whenever data should be retrieved.\n\nWe can then of course use that hook in a component to render data and the\nvarious states the query can be in, but if we take a quick look at the again...\n\nwe can see that in this example, it is implemented with axios, because, why not?\nBut the point is: THAT is your data-fetching library. React Query doesn't care\nhow you do it.\n\nThe only thing it cares about is if we are returning a or Promise.\n\nIn fact (and this is probably me talking as a library maintainer), if you're\nfiling an issue telling me you can't show a reproduction because your API is\nprivate, I'll likely be telling you that this is the simplest way to implement\nthe - no data fetching at all:\n\nAll we are doing is - return a resolved Promise. Of course, React Query goes\nvery well data fetching libraries like axios, fetch or graphql-request because\nthey all produce Promises.\n\nOnce we understand that React Query doesn't fetch data, it hopefully becomes\nclear that a whole class of questions around data fetching just disappear.\nQuestions like:\n\nAll questions around data fetching usually have the same answer:\n\n  * How can I define a baseURL with React Query ?\n  * How can I access response headers with React Query?\n  * How can I make graphQL requests with React Query?\n\nReact Query doesn't care! Just somehow return a Promise, please.\n\nRight, once we've got that, it's only fair to ask:\n\nIf React Query is no data fetching library, what is it? My answer to this\nquestion has always been:\n\nAn Async State Manager. Now it's important to understand what we mean by \"Async\nState‚Äù.\n\nTanner Linsley, the creator of React Query, gave a great talk in May 2020\ncalled: [It's Time to Break up with your \"Global\nState\"](https://tkdodo.eu/blog/<https:/www.youtube.com/watch?v=seU46c6Jz7E>).\n\nThe talk is still very relevant today, please watch it if you haven't already.\n\nThe gist of it is that we have, for the longest time, sliced our state into we\nneed it to live. Do we only need it in one component? We'll probably start out\nby using local state. Do we need it available higher up the tree?\n\nThen we move it up and potentially pass data down again as props. Do we need it\neven higher, or on a much broader scale?\n\nWe'd likely move it to a \"global state manager\" like redux or zustand, which\nlives outside of React and then distributes it globally to our application.\n\nAnd we've been doing this for all kinds of state - no matter if it's the toggle\nbutton we're clicking in our app or the list of issues or profile data we have\nto fetch over the network. We've treated them all exactly the same.\n\nThe shift in thinking comes when we split state differently - not it is used but\nby it is.\n\nBecause state we own completely and that is synchronously available (like, when\nI click that dark mode toggle button) has totally different needs than state\nthat is persisted remotely and asynchronously available, like a list of issues.\n\nWith async state or \"server state‚Äù, we only see a snapshot in time of when we\nfetched it. It can get out of date, because we are not the only owner of that\nstate. The backend, probably our database owns it. We have just borrowed it to\ndisplay that snapshot.\n\nYou might notice this when you leave a browser tab open for half an hour, and\nthen come back to it. Wouldn't it be nice to automatically see fresh and\naccurate data? That means WE have to keep it up-to-date, because other users can\nmake changes in the meantime as well. And because state is not synchronously\navailable, meta-information around that state, like loading and error states,\nneed to be managed as well.\n\nSo, keeping your data up-to-date automatically and managing async lifecycles\nisn't something you would get or need from a traditional, all-purpose state\nmanager. But since we have a tool that is geared towards async state, we can\nmake all that happen, and more. We just need to use the right tool for the right\njob.\n\nThe second part we need to understand is what a \"state manager\" is, and why\nReact Query is one. What state managers usually do is making your state\navailable in your app efficiently. The important part here is , put another way,\nI would frame it as:\n\nWe want updates please, but not too many.\n\nIf too many updates weren't a problem, we'd all just stick our state in React\nContext. But it is a real problem, and a lot of libraries try to solve this in\nvarious ways, some more magically than others. Redux and zustand - two popular\nstate management solutions - both offer a selector based api:\n\nThose make sure that our components are only subscribed to parts of the state\nthey are interested in. If other parts of the store update, those components\ndon't care. And the principle is that we can call those hooks anywhere in our\nApp to get access to that state, because the libraries make it globally\navailable.\n\nAnd with React Query, it's really not that different. Except that the part or\nslice you're subscribing to is defined by the QueryKey\n\nNow wherever we call our custom hook, we'll get updates if something changed in\nthe slice of the Query Cache. And if that isn't enough, we can take this a step\nfurther, because ReactQuery has selectors as well:\n\nNow we're talking \"fine-grained\" subscriptions, where components are only\ninterested in computed or derived results of what is stored. If we toggle one\nissue from \"opened\" to \"closed\", the component that uses the hook won't re-\nrender because the length hasn't changed.\n\nAnd just like with other state managers, we can (and very likely should) call\nwherever we need to, to get access to that data.\n\nThis makes all solutions that try certain things like calling to sync data from\nReact Query somewhere else or setting data into local state in the (already\ndeprecated) callback anti-patterns.\n\nAll of these are forms of state syncing that take away the single source of\ntruth, and are unnecessary because React Query is already a state manager, so we\ndon't need to put that state into another one.\n\nOkay okay you might be thinking, now I'm doing this, and I'm calling useQuery\nwherever I want to / need to. 3 components, 3x . But if some of our components\nare rendered conditionally, like when opening a Dialog or because we have\ndependent queries, we might start to see a lot of fetches to the same endpoint.\n\nYou might be thinking: ugh, I just fetched this like 2 seconds ago, why is it\nalready fetching again?? So you turn to the docs...\n\nand start to turn off everything, everywhere, all at once, just to not spam your\nbackend that much. Maybe we should've put our data in redux after all...\n\nBear with me for a second, because there is some logic to this madness. Why is\nReact Query making all those requests?\n\nIt brings us back all the way to the needs of async state: It can be outdated,\nso we want to update it at some point in time, and React Query does this by\ncertain triggers: window focus, component mount, regaining network connection\nand QueryKey change.\n\nWhenever one of these events occurs, React Query will refetch that query\nautomatically.\n\nBut that's not the whole story. The thing is: React Query will not do this for\nall Queries - only for Queries that are considered. And this brings us to the\nsecond important takeaway of the day:\n\nReact Query is also a data synchronization tool, but that doesn't mean it'll\nblindly refetch all queries in the background. This behaviour can be adjusted by\n, which defines \"the time until data goes stale\". The opposite of is , so put\nanother way, as long as data is considered , it will be given to us from the\ncache only, without a refetch. Otherwise, we'll get cached data AND a refetch.\n\nSo only stale queries will be updated automatically, but the thing is: staleTime\ndefaults to zero\n\nYep, zero as in zero milliseconds, so React Query marks everything as stale\ninstantly. That's certainly aggressive and can lead to overfetching, but instead\nof erroring on the side of minimizing network requests, React Query errors on\nthe side of keeping things up-to-date.\n\nNow defining is up to you - it highly depends on your resource and your needs.\nThere is also no \"correct\" value for .\n\nIf you are querying config settings that will only change when the server\nrestarts, can be a good choice.\n\nOn the other hand, if you have a highly collaborative tool where multiple users\nupdate things at the same time, you might be happy with .\n\nSo a very important part of working with React Query evolves around defining .\nAgain, there is no correct value, what I like to do is set a default globally\nand then potentially overwrite it when needed.\n\nOkay, let's quickly go back to the needs of async state one more time. We know\nthat React Query keeps our cache up-to-date if data is considered stale and one\nof those events occur.\n\nThe one event that is probably the most important of all and that I want to\nfocus on is the QueryKey change event.\n\nWhen would that event mostly occur? Well, that brings us to the last point:\n\nWe should treat parameters as dependencies.\n\nI really want to emphasize on this, even though it's already outlined in the\ndocs and I have written about it.\n\nIf you have parameters, like the filters in this example, that you want to use\ninside your to make a request, you have to add them to the .\n\nThis ensures a lot of things that make React Query great to work with: For one,\nit makes sure that entries are cached separately depending on their input, so if\nwe have different filters, we store them under different keys in the cache,\nwhich avoids race conditions.\n\nIt also enables automatic refetches when changes, because we go from one cache\nentry to the other. And it avoids problems with stale closures, which are\nusually pretty hard to debug.\n\nIt's so important that we've released our own eslint plugin. It can check if\nyou‚Äôre using something inside the and tells you to add it to the key. It's also\nauto fixable, and I can highly recommend using it.\n\nIf you want, you can think about the like the dependency Array for , but without\nthe drawbacks, because we don't have to think about referential stability.\n\nThere's no need for or to get involved here - not for the and not for the .\n\nNow lastly, this might introduce a new problem: We're now using wherever we need\nto, at any level in our App, but now we have dependencies to our Query that only\nexists in a certain part of the screen: What if I don't have access to when I\nwant to call ? Where is it coming from?\n\nThe answer, again, is: React Query doesn't care. It's a pure problem. Because\nthat applied filter is. And how you manage that is up to you.\n\nIt's still totally fine to use local state or global state managers for that as\nyou see fit. Storing in the url is often a good idea, too.\n\nAs an example, let's take a look at how this could look if we've put the filters\ninto a state manager like :\n\nThe only thing we‚Äôve changed is, instead of passing as input to our custom hook,\nwe are getting it from the store directly. This shows the power of composition\nwhen writing custom hooks.\n\nAnd we can see the clear separation between server state, managed by , and\nclient state, in this case, managed by . Every time we update in the store - no\nmatter where - the query will automatically run or read the latest data from the\ncache if available.\n\nThis pattern will enable us to use React Query as a true async state manager.\n\n  1. React Query is NOT a data fetching library - it‚Äôs an async state manager.\n  2. is your best friend - but you have to set it up to your needs.\n  3. Treat parameters as dependencies, and use our lint rule to enforce this.\n\nIf we change our thinking to follow these three points, we‚Äôll have an even\nbetter time working with React Query, much like a small tweak to how we tie our\nshoes can be a great quality of life improvement.\n\nNow I still owe you the solution to tying your shoes correctly.\n\nIt's really quite simple. When creating the loop, make sure to pull the shoelace\ntoward yourself first, then pull it through the gap.\n\nThis small difference will result in a knot that will stay horizontal and won't\ncome loose as easily.\n\nThere is also if you wanna go watch that.\n\nSo, that's all I got, thanks for listening. Be sure to follow me on , and\nsubscribe to my . React Query v5 is just around the corner and that is a good\nway to keep up-to-date. Thanks!\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# React Query and React Context\nURL: https://tkdodo.eu/blog/react-query-and-react-context\n\n# React Query and React Context\n\n‚Äî , , , , ‚Äî\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * **#22: React Query and React Context**\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Develop and launch modern apps with MongoDB Atlas, a resilient data\nplatform.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8269/0194f712-7252-72d0-810a-e0bae9128030/>)\n\nOne of the best traits of React Query is that you can use a query wherever you\nwant in your component tree: Your component can fetch its own data, co-located,\nright where you need it to be:\n\n```\n\nCopyProductTable: copy code to clipboard\n\n```\n\nTo me, this is great because it makes the decoupled and independent: It's\nresponsible for reading its own dependencies: Product Data. If it's in the cache\nalready, great, we'll just read it. If not, we'll go fetch it. And we can see\nsimilar patterns emerge with React Server Components. They, too, allow us to\nfetch data right inside our components. No more arbitrary splits between and ,\nor and components.\n\nSo being able to fetch data right in a component, where you need it, is\nimmensely useful. We can literally take the component and move it anywhere in\nour App, and it will just work. The component is very , which is the main reason\nwhy I'm advocating for accessing your query directly wherever you need to (via a\ncustom hook), both in [#10: React Query as a State\nManager](https://tkdodo.eu/blog/<react-query-as-a-state-manager>) and [#21:\nThinking in React Query](https://tkdodo.eu/blog/<thinking-in-react-query>).\n\nIt's not a silver bullet though - it comes with tradeoffs. This shouldn't be\nsurprising, because at the end of the day, everything is a tradeoff. But what\nare we trading in here, exactly?\n\nFor a component to be autonomous, it means it has to handle cases where query\ndata is not available (yet), in particular: loading and error states. This is\nnot a big deal for our component, because very often, when it first loads, it\nwill actually display that .\n\nBut there are lots of other situations where we just want to read some\ninformation from some parts of our query, where we that the query has been\nalready used further up the tree. For example, we might have a that contains\ninformation about the logged-in user:\n\n```\n\nCopyuseCurrentUserQuery: copy code to clipboard\n\n```\n\nWe will probably use this query quite early in our component tree, to check\nwhich user rights the logged-in user has, and it might further determine if we\ncan actually see the page or not. It is information that we want everywhere on\nour page.\n\nNow further down the tree, we might have a component that wants to display the ,\nwhich we can get from the hook:\n\n```\n\nCopyUserNameDisplay: copy code to clipboard\n\n```\n\nOf course, TypeScript won't let us, because is potentially undefined. But we\nknow better - it can't be undefined, because in our situation, the won't be\nrendered without the query being already initiated further up the tree.\n\nThat's a bit of a dilemma. Do we want to just shut up TS here and do , because\nwe know it will be defined? Do we play it safe and do (which is possible here,\nbut might not be so easy to pull off in other situations)? Do we just add a\nguard: ? Or do we add proper loading and error handling to all 25 places where\nwe call ?\n\nTo be honest - I think all of those ways are kind of suboptimal. I don't want to\nlitter my codebase with checks that can \"never happen\" (to the best of my\ncurrent knowledge). But I also don't want to ignore TypeScript, because (as\nusual), TS is right.\n\nOur problem comes from the fact that we have an : A dependency that only exists\nin our head, in our knowledge of the application structure, but it's not visible\nin the code itself.\n\nEven though we know that we can safely call without having to check for data not\nbeing defined, no static analysis can verify this. Our co-workers might not know\nit. I myself might not know this anymore 3 months from now.\n\nThe most dangerous part is that it might be true now, but it might no longer be\ntrue in the future. We can decide to render another instance of somewhere in our\nApp, where we might not have user data in the cache, or where we might have user\ndata in the cache , e.g. if we have visited a different page before.\n\nThis is quite the opposite of the component: Instead of being resilient to\nchange, it becomes error-prone to refactorings. We wouldn't expect the component\nto break just because we move some seemingly unrelated components around...\n\nThe solution is, of course, to make the dependency . And there is no better way\nto do this than with React Context:\n\nThere's quite the myth about React Context, so let's get this straight: No,\nReact Context is not a state manager. It can become a seemingly good solution\nfor state management when combined with or , but tbh, I've never really liked\nthis approach, as I've been burned by situations like these too much:\n\n[üïµÔ∏è We've fixed a huge performance problem this week by moving useState +\ncontext over to zustand. It was the same amount of code. The lib is < 1kb.‚öõÔ∏è\nDon't use context for state management. Use it for dependency injection only.\nThe right tool for the\njob!](https://tkdodo.eu/blog/<https:/x.com/TkDodo/status/1495072479118864398>)\n\nSo you'll likely be better off just using a dedicated tool. , maintainer of\nRedux and writer of very long blog posts, has a good article on that topic:\n[Blogged Answers: Why React Context is Not a \"State Management\" Tool (and Why It\nDoesn't Replace\nRedux)](https://tkdodo.eu/blog/<https:/blog.isquaredsoftware.com/2021/01/context-\nredux-differences/>).\n\nMy tweet mentions it already: React Context is a tool. It allows you to define\nwhich \"things\" your component needs to work, and any parent is responsible for\nproviding that information.\n\nThis is conceptually the same as prop-drilling, which is the process of passing\nprops down via multiple layers. Context allows you to do the same: Take some\nvalues and pass them as props to children, except that you can leave out a\ncouple of layers:\n\nWith context, you just skip the middle man. In our example, it can help us make\nthat dependency explicit: Instead of reading the directly in all components\nwhere we want to skip the data-availability check, we read it from React\nContext. And that context will be filled by the parent that actually does the\nfirst check:\n\n```\n\nCopyCurrentUserContext: copy code to clipboard\n\n```\n\nHere, we take the and put the resulting data into React Context, if it exists\n(by eliminating loading and error states upfront). We can then read from that\ncontext safely in our children, e.g. the component:\n\n```\n\nCopyUserNameDisplay-with-React-Context: copy code to clipboard\n\n```\n\nWith that, we have made our implicit dependency (we know data has been fetched\nearlier in the tree) explicit. Whenever someone looks at , they will know that\nthey need to have data provided from the . That is something you can keep in\nmind when refactoring. If you change where the Provider is rendered, you will\nalso know that this will affect all children using that context. That's\nsomething you can't know when a component is just using a query - because\nqueries are usually global in your whole app, and data might or might not exist.\n\nTypeScript still won't like it much, because React Context is designed to also\nwork a Provider, where it will give you the default value of the Context, and\nthat's in our case. Since we never want to work in a situation where we are\noutside a Provider, we can add an invariant to our custom hook:\n\n```\n\nCopycontext-with-invariant: copy code to clipboard\n\n```\n\nThis method ensures that we will fail fast and with a good error message if we\never accidentally access in the wrong place. And with that, TypeScript will\ninfer the value for our custom hook, so we can safely use it and access\nproperties on it.\n\nYou might be thinking: Isn't this \"state syncing\" - copying one value from React\nQuery and putting into another method of state distribution?\n\nThe answer is: No, it is not! The single source of truth is still the query.\nThere is no way to change the context value apart from the Provider, which will\nalways reflect the latest data the query has. Nothing gets copied here, and\nnothing can get out of sync. Passing from React Query as a prop to a child\ncomponent is also not \"state syncing\", and since context is similar to prop\ndrilling, it's also not \"state syncing\".\n\nNothing is without drawbacks, and neither is this technique. Specifically, it\nmight create network waterfalls, because your component tree will stop rendering\n(it \"suspends\") at the Provider, so child components won't be rendered and can't\nfire off network requests, even if they are unrelated.\n\nI'd mostly consider this approach for data that is for my sub-tree: User\ninformation is a good example because we might not know what to render anyway\nwithout that data.\n\nTalking about Suspense: Yes, you can achieve a similar architecture with React\nSuspense, and yes, it has the same drawback: potential request waterfalls, which\nI've already written about in [#17: Seeding the Query\nCache](https://tkdodo.eu/blog/<seeding-the-query-cache>).\n\nOne problem is that in the current major version (v4), using on your query won't\ntype narrow , because there are still ways to disable the query and have it not\nrun.\n\nHowever, since v5, there is an explicit hook, where data is guaranteed to be\ndefined once the component renders. With that, we can do:\n\n```\n\nCopyUserNameDisplay-with-suspense: copy code to clipboard\n\n```\n\nand TypeScript will be happy about it. üéâ\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/why-you-want-react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * **#23: Why You Want React Query**\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Find out how Algolia AI Search can instantly and precisely understand your\nuser's\nintent.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8293/0194f712-8823-7460-b31c-e263dc10ee0b/>)\n\nIt's no secret that I ‚ù§Ô∏è React Query for how it simplifies the way we're\ninteracting with asynchronous state in our React applications. And I know a lot\nof fellow devs feel the same.\n\nSometimes though, I come across posts claiming that you don't need it to do\nsomething as as fetching data from a server.\n\n> We don't need all the extra features that React Query has to offer, so we\n> don't want to add a 3rd party library when we can just as easily fire a in a .\nTo some degree, I think that's a valid point - React Query gives you a lot of\nfeatures like , , , , , ... and about a million more that would go way beyond\nthe scope of this article. It's totally fine if you don't need them, but I still\nthink this shouldn't stop you from using React Query.\n\nSo let's instead look at the standard fetch-in- example that came up on lately,\nand dive into why it might be a good idea to use React Query for those\nsituation, too:\n\n```\n\nCopyfetch-in-useEffect: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\nIf you think this code is fine for simple use cases where you don't need\nadditional features, let me tell you that I immediately spotted üêõ ü™≤ hiding in\nthese 10 lines of code.\n\nMaybe take a minute or two and see if you can find them all. I'll wait...\n\nHint: It's not the dependency array. That is fine.\n\nThere are reasons why the recommend using either a framework or a library like\nReact Query for data fetching. While making the actual fetch request can be a\npretty trivial exercise, making that state available in your application is\ncertainly not.\n\nThe effect is set up in a way that it re-fetches whenever changes, which is\ncertainly correct. However, network responses can arrive in a different order\nthan you sent them. So if you change the category from to and the response for\narrives before the response for , you'll end up with the wrong data in your\ncomponent.\n\nAt the end, you'll be left with an state: Your local state will say that you\nhave selected, but the data you're rendering is actually .\n\nThe React docs say that we can fix this with a cleanup function and an boolean,\nso let's do that:\n\n```\n\nCopyignore-flag: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\nWhat happens now is that the effect cleanup function runs when changes, setting\nthe local flag to true. If a fetch response comes in after that, it will not\ncall anymore. Easy peasy.\n\nIt's not there at all. We have no way to show a pending UI while the requests\nare happening - not for the first one and not for further requests. So, let's\nadd that?\n\n```\n\nCopyloading-state: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\nInitializing with an empty array seems like a good idea to avoid having to check\nfor all the time - but what if we fetch data for a category that has no entries\nyet, and we actually get back an empty array? We'd have no way to distinguish\nbetween \"no data yet\" and \"no data at all\". The loading state we've just\nintroduced helps, but it's still better to initialize with :\n\n```\n\nCopyempty-state: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\n## 4. Data & Error are not reset when category changes üîÑ\n\nBoth and are separate state variables, and they don't get reset when changes.\nThat means if one category fails, and we switch to another one that is fetched\nsuccessfully, our state will be:\n\n```\n\n```\n\nThe result will then depend on how we actually render JSX based on this state.\nIf we check for first, we'll render the error UI with the old message even\nthough we have valid data:\n\n```\n\nCopyerror-first: copy code to clipboard\n\n```\n\nIf we check data first, we have the same problem if the second request fails. If\nwe always render both error and data, we're also rendering potentially outdated\ninformation . üòî\n\nTo fix this, we have to reset our local state when category changes:\n\n```\n\nCopyreset-state: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\n## 5. Will fire twice in üî•üî•\n\nOkay, this is more of an annoyance than a bug, but it's definitely something\nthat catches new React developers off guard. If your app is wrapped in , React\nwill intentionally in development mode to help you find bugs like missing\ncleanup functions.\n\nIf we'd want to avoid that, we'd have to add another \"ref workaround\", which I\ndon't think is worth it.\n\nI didn't include this in the original list of bugs, because you'd have the same\nproblem with React Query: doesn't reject on HTTP errors, so you'd have to check\nfor and throw an error yourself.\n\n```\n\nCopyerror-handling: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\nOur little \"we just want to fetch data, how hard can it be?\" hook became a giant\nmess of spaghetti code üçù as soon as we had to consider edge cases and state\nmanagement. So what's the takeaway here?\n\nData Fetching is simple. Async State Management is not.\n\nAnd this is where comes in, because React Query is NOT a data fetching library -\nit's an async state manager. So when you say that you don't for doing something\nas simple as fetching data from an endpoint, you're actually right: Even with\nReact Query, you need to write the same code as before.\n\nBut you still to make that state predictably available in your app as easily as\npossible. Because let's be honest, I haven't written that boolean code before I\nused React Query, and likely, neither have you. üòâ\n\nWith React Query, the above code becomes:\n\n```\n\nCopyreact-query: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\nThat's about 50% of the spaghetti code above, and just about the same amount as\nthe original, buggy snippet was. And yes, this addresses all the bugs we found\nautomatically:\n\n  * üèéÔ∏è There is no race condition because state is always stored by its input (category).\n  * üïê You get loading, data and error states for free, including discriminated unions on type level.\n  * üóëÔ∏è Empty states are clearly separated and can further be enhanced with features like .\n  * üîÑ You will not get data or error from a previous category unless you opt into it.\n  * üî• Multiple fetches are efficiently deduplicated, including those fired by .\n\nSo, if you're still thinking that you don't want React Query, I'd like to\nchallenge you to try it out in your next project. I bet you'll not only wind up\nwith code that is more resilient to edge cases, but also easier to maintain and\nextend. And once you get a taste of all the features it brings, you'll probably\nnever look back.\n\nA lot of folks on twitter mentioned missing request cancellation in the original\nsnippet. I don't think that's necessarily a bug - just a missing feature. Of\ncourse, React Query has you covered here as well with a pretty straightforward\nchange:\n\n```\n\nCopycancellation: copy code to clipboard\n\n// Return JSX based on data and error state\n\n```\n\nJust take the you get into the , forward it to , and requests will be aborted\nautomatically when category changes. üéâ\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/the-query-options-api\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * **#24: The Query Options API**\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with MongoDB Atlas, the leading developer data\nplatform](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8268/0194f712-a2c6-7262-90ea-8f2a84f23c57/>)\n\nReact Query version 5 was released about three months ago, and with it, we got\none of the biggest \"breaking\" changes in the library's history. All of our\nfunctions now only get one object passed, instead of multiple arguments. We call\nthis object the , because it contains all the options you need to create a\nquery:\n\n```\n\n```\n\nThis isn't only true for calls, but also for imperative actions like\ninvalidating a query:\n\n```\n\n```\n\nNow technically, this API isn't new. Most of our functions had overloads, so\neven in v3, you could already pass an object instead of multiple arguments. It's\njust that it wasn't really advocated for. All examples, the docs and many blog\nposts (including this one) used the old API, which is why this was a breaking\nchange for most apps.\n\nSo why did we do it?\n\nFirst of all, having all those overloads is a chore for maintainers, and it's\nalso not clear for users. Why can I call the same function in multiple ways - is\none better than the other? So, streamlining the API, thus making it easier for\nnew starters to understand it, was one goal. \"Always pass one object\" is as\nsimple and extensible as it gets.\n\nBut also, it turns out that one object to rule them all is simply a very good\nabstraction for when you want to share query options between different\nfunctions. I discovered this \"by accident\" when I wrote the [React Query meets\nReact Router](https://tkdodo.eu/blog/<react-query-meets-react-router>) article,\nwhere want to share query options between prefetching and our call. Now usually,\nyou could just write custom hooks as your primary way to re-use queries. But\nthat doesn't work when imperative function calls like are involved. So I came up\nwith something, and noted this as a good pattern:\n\n{/_NOTE: The tweet id leads to Alex's now protected X account_ /}\n\n[First time I saw this React Query pattern was 's React Router blog\npost](https://tkdodo.eu/blog/<https:/x.com/ralex1993/status/1570036707134676994>)\n\nTurns out, if all your functions have the same interface - accepting a single\nobject - it makes a lot of sense to abstract that object away into a query\ndefinition. Once you have that, you can pass it everywhere:\n\n```\n\nCopytodos-query: copy code to clipboard\n\n```\n\nIn hindsight, this pattern just feels beautiful as the main abstraction for\nqueries, and I wanted to apply it everywhere. There was just one problem:\n\nThe way TypeScript handles excess properties is quite special. If you inline\nthem, TypeScript will be like: Why are you doing this - it doesn't make any\nsense, I'll error out:\n\n```\n\nCopyinlined-objects: copy code to clipboard\n\n```\n\nObject literal may only specify known properties, but 'stallTime' does not exist\nin type 'UseQueryOptions<Todo[], Error, Todo[], string[]>'. Did you mean to\nwrite 'staleTime'?(2769)\n\nWhich is cool, because it catches typos like the one above. But what if you\nabstract the whole object away into a constant, like our pattern suggests?\n\n```\n\nCopyno-error: copy code to clipboard\n\n```\n\nTypeScript is quite relaxed in these situations, because at runtime, the \"extra\"\nproperty doesn't hurt, and you might want to use that object in a context where\nthe property is required. TypeScript can't know that. And since is optional, we\nare now just passing it. Of course, this is \"valid\", but it's not what we'd\nexpect, and it can be a costly mistake to find.\n\nThat's why we've introduced a type-safe helper function in v5 called . At\nruntime, it doesn't do anything:\n\n```\n\nCopyqueryOptions: copy code to clipboard\n\n```\n\nBut on type level, it's a real powerhouse that not only fixes the above typo\nissue (see the ) - it can also help us make other parts of the more type-safe:\n\nThere's one thing about and similar functions that has always been a bit\nannoying in React Query: On type level, they return . That's because React Query\ndoesn't have an up-front, centralized definition, so when you call , there's no\nway how the library could know what type will be returned.\n\nWe are forced to help out ourselves by providing the type parameter to the\nfunction call:\n\n```\n\nCopymanual-type-parameter: copy code to clipboard\n\n//  ^? const todos: Todo[] | undefined\n\n```\n\nTo be clear, this isn't at all safer than just using type assertions, but at\nleast will be added to the union for us. If we refactor what our endpoint\nreturns, we won't be notified here of the new type. üòî\n\nBut now that we have a function that co-locates and , we can associate the type\nof the and \"tag\" our with it. Notice what happens when we pass the that was\ncreated via to :\n\n```\n\nCopytagged-query-key: copy code to clipboard\n\n//  ^? const todos: Todo[] | undefined\n\n```\n\nThis is pure TypeScript magic, contributed by the one and only . If we look at ,\nwe can see that it's not only a string array, but it also contains information\nabout what the returns:\n\n```\n\nCopydataTagSymbol: copy code to clipboard\n\n```\n\nThat information will then be read out by (and other functions like , too), to\ninfer the type for us. This brings a whole new level of type-safety to React\nQuery, while at the same time making it easier for us to re-use query options. A\nhuge win in DX. üöÄ\n\nSo, if you're asking me, I want to use this pattern and the helper everywhere. I\nwould even take it to a point where custom hooks won't be my first choice for\nabstractions. They seem a bit pointless if all they do is:\n\n```\n\nCopycustom-hooks: copy code to clipboard\n\n```\n\nThere's nothing wrong with calling in your component directly, especially if you\nsometimes want to mix it with . Of course, if the hook does more, like\nadditional memoization with , it's still perfectly fine to add it. But I\nwouldn't immediately reach for it like I did before.\n\nAdditionally, I'm seeing in a bit of a different light now. I've come to learn\nthat:\n\nSeparating QueryKey from QueryFunction was a mistake\n\nThe defines the dependencies to our - everything we use inside it must go into\nthe key. So why define keys in one central place while having the functions far\na way from them in our custom hooks?\n\nHowever, if we the two patterns, we're getting the best of all worlds: Type-\nsafety, co-location and great DX. üöÄ\n\nAn example query factory could look something like this:\n\n```\n\nCopyquery-factory: copy code to clipboard\n\n```\n\nIt contains a mix of key-only entries that we can use to build a hierarchy and\nfor query invalidation, as well as full query objects created with the helper.\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# Automatic Query Invalidation after Mutations\nURL: https://tkdodo.eu/blog/automatic-query-invalidation-after-mutations\n\n# Automatic Query Invalidation after Mutations\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * **#25: Automatic Query Invalidation after Mutations**\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8272/0194f712-b9b3-7f12-9dc2-3087fbbf4ca5/>)\n\nQueries and Mutations are two sides of the same coin. A defines an asynchronous\nresource for reading, which often comes from data fetching. A on the other hand\nis an action to update such a resource.\n\nWhen a Mutation finishes, it very likely affects Queries. For example, updating\nan will likely affect the list of . So it might be a bit surprising that React\nQuery does not link Mutations to Queries at all.\n\nThe reason behind this is quite simple: React Query is totally about how you\nmanage your resources, and not everyone likes re-fetching after a Mutation.\nThere are cases where the Mutation returns updated data, which we'd want to then\n[put into the cache\nmanually](https://tkdodo.eu/blog/<https:/tanstack.com/query/v5/docs/framework/react/guides/updates-\nfrom-mutation-responses>) to avoid another network roundtrip.\n\nThere are also many different ways of how you'd want to do invalidation:\n\n  * Do you invalidate in or ? The former will only be invoked when the Mutation succeeded, while the latter will also run in case of errors.\n  * Do you want to invalidations? will result in the Mutation staying in state until the refetch has finished. This can be a good thing, for example if you'd want your form to stay disabled until then, but it might also be not what you want in case you want to navigate from a detail screen to an overview page as soon as possible.\n\nSince there isn't a one-size-fits-all solution, React Query provides nothing out\nof the box. However, it's not at all difficult to implement automatic\ninvalidation the way you want them to behave in React Query thanks to the .\n\nMutations have callbacks - , and , which you have to define on each separate .\nAdditionally, the same callbacks exist on the . Since there is only one for our\napplication, those callbacks are \"global\" - they are invoked for Mutation.\n\nIt's not quite obvious how to create a with callbacks, because in most examples,\nthe is implicitly created for us when we create the . However, we can also\ncreate the cache itself manually and provide callbacks to it:\n\n```\n\nCopycreate-MutationCache: copy code to clipboard\n\n```\n\nThe callbacks get the same arguments as the ones on , except that they will also\nget the Mutation instance as last parameter. And just like the usual callbacks,\nreturned Promises will be awaited.\n\nSo how can the global callback help us with automatic invalidation? Well - we\ncan just call inside the global callback:\n\n```\n\nCopyautomatic-invalidation: copy code to clipboard\n\n```\n\nWith just 5 lines of code, we get a similar behaviour to what frameworks like\nRemix (sorry, React-Router) are doing as well: Invalidate everything after every\nsubmission. Shout out to Alex for showing me this path:\n\n[I just invalidate everything on every\nmutation](https://tkdodo.eu/blog/<https:/x.com/alexdotjs/status/1744467890277921095>)\n\n### But isn't that excessive ?\n\nMaybe, maybe not. It depends. Again, that's why it isn't built in, because there\nare too many different ways to go about it. One thing we have to clarify here is\nthat an invalidation doesn't always equate to a .\n\nInvalidation merely refetches all Queries that it matches, and marks the rest as\n, so that they get refetched when they are used the next time.\n\nThis is usually a good trade-off. Consider having an Issue List with filters.\nSince each filter should be part of the QueryKey, we'll get multiple Queries in\nthe cache. However, I'm only ever viewing one of those Queries at the same time.\nRefetching them all would lead to lots of unnecessary requests, and there's no\nguarantee that I will ever go back to a list with one of those filters.\n\nSo invalidation only refetches what I currently see on the screen (active\nQueries) to get an up-to-date view, and everything else will be refetched if we\never need them again.\n\n## Tying invalidation to specific Queries\n\nOkay, hold on. What about fine-grained revalidation? Why would we invalidate the\ndata when we add an to our list? That barely makes sense ...\n\nAgain, a trade-off. The code is as simple as it gets, and I would prefer\nfetching some data more often than strictly necessary over missing a refetch.\nFine-grained revalidation is nice if you know exactly what you need to refetch,\nand that you'll never need to extend those matches.\n\nIn the past, we've often done fine-grained revalidation, just to find out that\nwe'd need to add another resource into the mix later which doesn't fit the used\ninvalidation pattern. At that point, we had to go through all mutation callbacks\nto see if that resource needed to be refetched as well. That's cumbersome and\nerror-prone.\n\nOn top of that, we often use a medium-sized of ~2 minutes for most our Queries.\nSo the impact of invalidating after an unrelated user interaction is negligible.\n\nOf course, you can make your logic more involved to make your revalidation\nsmarter. Here are some techniques I've used in the past:\n\nMutationKey and QueryKey have nothing in common, and the one for Mutations is\nalso optional. You can tie them together if you want by using the MutationKey to\nspecify which Queries should be invalidated:\n\n```\n\nCopymutationKey: copy code to clipboard\n\n```\n\nThen, you can give your Mutation a to invalidate everything related only. And if\nyou have a Mutation without a key, it would still invalidate everything. Nice.\n\nI often mark Queries as \"static\" by giving them . If we don't want those Queries\nto be invalidated, we can look at the setting of a Query and exclude those via\nthe filter:\n\n```\n\nCopynonStaticQueries: copy code to clipboard\n\n```\n\nFinding out the actual for a Query is not that trivial, because is an observer\nlevel property. But it's doable, and we can also combine the filter with other\nfilters like . Neat.\n\nWe can use to store arbitrary, static information about a Mutation. As an\nexample, we can add an field to give \"tags\" to our mutation. These tags can then\nbe used to fuzzily match Queries we'd want to invalidate:\n\n```\n\nCopythe-meta-option: copy code to clipboard\n\n// invalidate all matching tags at once\n\n// or everything if no meta is provided\n\n```\n\nHere, we still use the function to get a single call to . But inside of it, we\ndo fuzzy matching with - a function you can import from React Query. It's the\nsame function that gets used internally when passing a single as a filter, but\nnow, we can do it with multiple keys.\n\nThis pattern is probably only slightly better than just having callbacks on\nitself, but at least we don't need to bring in the QueryClient with every time.\nAlso, if we combine this with invalidating everything per default, this will\ngive us a good way to opt-out of that behaviour.\n\n## To Await or not to Await\n\nIn all the examples shown above, we are never an invalidation, and that's fine\nif you want your mutations to finish as fast as possible. One specific situation\nthat I have come across a lot is wanting to invalidate everything, but have the\nMutation stay pending until one important refetch is done. For example, I might\nwant label specific Queries to be awaited after updating a label, but I wouldn't\nwant to wait until everything is done refetching.\n\nWe can build this into our solution by extending how that structure is defined,\nfor example:\n\n```\n\nCopymeta-awaits: copy code to clipboard\n\n```\n\nOr, we can take advantage of the fact that callbacks on the MutationCache run\ncallbacks on . If we have our global callback set-up to invalidate everything,\nwe can still add a local callback that just what we want it to:\n\n```\n\nCopylocal-onSuccess: copy code to clipboard\n\n// returning the Promise to await it\n\n```\n\n  * First, the global callback runs and invalidates all Queries, but we since we neither nor anything, this is a \"fire-and-forget\" invalidation.\n  * Then, our local callback will run immediately after that, where we will create a Promise for invalidating the only. Since we are returning that Promise, the Mutation will stay pending until are refetched.\n\nI think this shows that it's not a lot of code to add an abstraction that you're\ncomfortable with for automatic invalidation. Just keep in mind that every\nabstraction has a cost: It's a new API that needs to be learned, understood and\napplied properly.\n\nI hope by showing all these possibilities, it's a bit clearer why we have\nnothing built into React Query. Finding an API that is flexible enough to cover\nall cases without being bloated is not an easy thing to do. For this, I prefer\nto give the tools to build this in user-land.\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/how-infinite-queries-work\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * **#26: How Infinite Queries work**\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[with MongoDB Atlas, the leading developer data\nplatform](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8268/0194f712-d0fc-7f32-9277-7c6223ebab21/>)\n\nThis week, a very interesting was filed for in React Query. It was interesting\nbecause up to this point, I firmly believed that React Query doesn't have any\nbugs.\n\nOkay, not really, but I was pretty sure it doesn't have any bugs that would a)\naffect a large number of users and b) would be because of some architectural\nconstraint in the library itself.\n\nWe do of course have edge-case bugs for quite specific situations that need\nworkarounds (can't really live without those) and also some known limitations\nthat might be annoying to accept, for example, that suspense is not working with\nquery cancellation.\n\nBut this bug report hit different. It was . We also didn't regress here - it has\nalways worked this way. It could still be classified as an edge case, because\nfor it to happen, you would need to:\n\n  * Have an Infinite Query that has already once successfully fetched multiple pages.\n  * Have a refetch where fetching at least one page succeeded, but then the next page failed to fetch.\n  * Use at least one retry (default is three).\n\nThis likely won't hit you every day, but it also isn't a huge edge-case. I was\nsurprised that in the last four years, no one has reported this. So I asked on\ntwitter and it seems like users have been getting this bug in the past, but also\ndidn't think React Query would have such a huge flaw and thus didn't report it.\nSeems like we're at least all aligned on the overall quality in React Query. üôå\n\nTo understand the issue (and why it freaked me out initially), we have to\nunderstand how infinite queries are different from normal \"single queries\".\n\nInfinite queries are React Query's way to make those doom-scrolling pages we all\nhate so much somewhat simple to implement. In many ways, they are identical to\nsingle queries.\n\nIn our cache, every query is represented as an instance of the class (If you\nhaven't read , now would be a good time). That instance is responsible for\nmanaging the state around the query, and it also holds the for the current\nfetch. That's what makes work - if is called while the query is already in\nfetching state, the active promise will be re-used.\n\nFurther, the query holds an instance of a , which is singlehandedly responsible\nfor doing all logic around retries. If a query wants to fetch data, it tells the\nto start, and it'll get a back. That promise will only resolve or reject after\nall retries have been used up.\n\nA simplified, pseudo-code version would look something like this:\n\n```\n\nCopyretryer: copy code to clipboard\n\n```\n\nThe will call the passed to it, and it might call it multiple times when doing\nretries (this is important for understanding the bug, so remember this). All of\nthis is the same for single queries and infinite queries, as there is no\nseparate representation of an in the cache.\n\nThe only thing that really distinguishes infinite queries is how is structured\nand how we retrieve that . Usually, what you return from the winds up directly\nin the cache - a simple 1:1 relationship.\n\nWith infinite queries, every single call of the will only return one part - one\n- of the whole data structure. The pages are like a linked list, where every\npage depends on the previous one to get its data.\n\nBut conceptually, it's still just one query that lives under one QueryKey. We\nachieve the difference by attaching a different to it.\n\nI wasn't totally honest before about the fact that the gets passed directly to\nthe . There is a thin layer around it. For single queries, it's set to executing\nthe only. But for infinite queries, it will take the function from the :\n\n```\n\nCopyquery-behavior: copy code to clipboard\n\n```\n\nThe behavior for an infinite query knows what it has to do when it is being run.\nFor example, when you call , it knows to call the passed to it once and append\nthe page to the cached data. If a refetch happens, it executes the in a loop,\nalways calling to ensure consistency. It might look something like this:\n\n```\n\nCopyInfiniteQueryBehavior: copy code to clipboard\n\n```\n\nI think conceptually, this is a brilliant design. All we need to do to make a\nquery an infinite query is to attach the to it, and the rest works just the\nsame. The function on the literally does just this:\n\n```\n\nCopyfetchInfiniteQuery: copy code to clipboard\n\n```\n\nNothing more to be done. No differences in caching, revalidation or\nsubscriptions. So where's the bug?\n\nIt has to do with the hierarchy of things: The holds the , and the receives the\nreturned from the . As we established earlier, the might fire the multiple\ntimes, namely if it catches an error and retries.\n\nSince the has the fetching loop, the whole loop will re-start and re-fetch in\ncase of a retry. This doesn't matter if the first page failed to fetch, but if a\npage in the middle fails (the bug reproduction mentions rate limiting as a\nrealistic example), we will re-set the loop and start from scratch. With rate\nlimiting, this means we might never succeed in fetching all pages!\n\nThis freaked me out because I was questioning the architecture. Do we need to\nreverse the order? Does every fetch inside the need its own retryer? That would\nbe a huge refactoring, and it would likely also affect single queries.\n\nI couldn't stop thinking about this bug. I didn't want to completely re-write\nthose layers. I thought that the only thing missing was having the remember at\nwhich point to re-start the loop. It turns out, this is trivial with javascript\nclosures. We can hoist the relevant information out of the returned function, so\nwhen it's invoked again, it will \"remember\" where it was:\n\n```\n\nCopyhoisting: copy code to clipboard\n\n```\n\nThis way, when fails, the will pause and eventually call the again. But now, it\nwill know where it has to continue, and it will also still retain the\ninformation about previously successfully fetched pages. üéâ\n\nSure, this means a setting of means three retries over all pages, not three\nretries per page, but it's still consistent with how single queries work - it's\nthree retries , no matter how often it actually fetches.\n\nIf you want to see the actual fix, the PR can be found on . Also thanks to for\nworking with me on this and for creating the initial failing test case. üôè\n\nOf course I added a regression in that PR and broke , but that's a story for\nanother day ...\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# React Query API Design - Lessons Learned\nURL: https://tkdodo.eu/blog/react-query-api-design-lessons-learned\n\n# React Query API Design - Lessons Learned\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * **#27: React Query API Design - Lessons Learned**\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Automate site indexing, catalog pages, & refine your search accuracy with\nAlgolia‚Äôs website\ncrawler](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8328/0194f712-e664-7173-a5f4-4673e1055a83/>)\n\nHere are the slides + transcript from the talk I recently gave at the conference\nin London. You can swipe left or right or use the arrow buttons / arrow keys to\nswitch between the slides. You can also find the recording on . Enjoy!\n\nHello everyone üëã I'm super excited to be here today, because this is the first\ntime that I'm giving a live talk at an in-person conference, and I'm very happy\nthat it's happening at React Advanced in London today.\n\nMy name is Dominik, and I'm a Software Engineer from Vienna, where I work as a\nfrontend tech lead at Adverity. You can find me as TkDodo online almost\neverywhere, and for the last three and a half years,\n\nI have maintained a quite popular open source React Library React Query\n\nsorry, TanStack React Query as we call it these days.\n\nQuick question, raise your hands - who of you has heard about react query? Who\nhas worked with it?\n\nThat's great - it means you might know some of the APIs I'm gonna talk about,\nbecause today, I want to...\n\n... walk you through some of the API design choices that we made in React Query,\ntell some stories about things that went well, but also highlight tradeoffs and\nmistakes that we made, and what lessons we can all learn from those. And I want\nto talk about that, mainly for two reasons:\n\n1. API Design is hard.\nIf you don't believe me, Julius said it. Very smart guy, he maintains tRPC, also\ncontributes to React Query. If he says it, it's probably right.\n\nand 2. I think React Query has a really really sweet API, which I think is part\nof why React Query has become so successful in the last couple of years.\n\nNow of course I can't take credit for that - Tanner Linsley made the library and\ndesigned most APIs, and he has a very good tweet summarizing the goal:\n\n@Tan_Stack Query's API is actually medium sized when you unpack it all, but the\nmost important part is that you can understand and learn how to use it by\nstarting with a single function that provides 80% of the entire value\nproposition first try. From there, the rest of its API can be gradually learned\nif needed.\n\nAnd I think that's what it takes for a library to become popular -\n\nIt needs to be both minimal and intuitive as well as powerful and flexible. Now\nfor any given API...\n\n... those two things are usually at the opposite side of the same scale.\n\nTake for example: very good example for a minimal API that does one thing very\nwell, no surprises, super intuitive.\n\nOn the other side of the spectrum, I'd see, which is very powerful (you can\nimplement all array functions with reduce) and flexible, but can be hard to\nunderstand and if that's the only API we have available, we'd also not be happy.\n\nSo the missing part is the second scale, which is usually \"app complexity\". As\napp complexity grows, your APIs should likely become more powerful & flexible.\n\nSo on that scale, would be right about here (bottom left) if you pass the\nminimal required options to it:\n\nSimple API, easy to use, but it gives you a ton of things:\n\nCaching, Request Deduplication, stale-while-revalidate background updates,\nglobal state management, automatic garbage collection, handling loading states,\nerror states + retries, the list goes on...\n\nThen you might add a useMutation for performing updates and tying them to\nqueries with query invalidation; that's already a bit more code, but you can\nreally get very far with just those two (useQuery and useMutation).\n\nAnd as your app complexity grows,\n\n...so does the flexibility of the Query APIs that you are using. You might want\nto add an optimistic update, or an infinite query - those are certainly a bit\nmore involved.\n\nAnd all the way on the right side of the scale, we have our Persister Plugins\nand fine-grained direct cache subscriptions (which we e.g. use to build the\ndevtools). Now you don't need to learn those when you're starting out, but once\nyou reach a certain app complexity, you are probably happy that those exist.\n\nOkay, so we got to this API that evolves with you ...\n\n...through careful planning, lots of iteration and a couple of major versions.\nSo that gets me right to my first learning I had as an open source maintainer\n\nI'm no longer excited about major versions (and probably neither should you).\n\nI think API design is especially hard in open source because whatever we decide\n- we can't easily revert it.\n\nAt adverity, we used to distribute our design-system via a private npm registry.\nNow we have a monorepo so we don't need to anymore, but we adhered to semantic\nversioning, and do you know what the latest version of that was?\n\nNobody cared. It's just numbers going up. Most projects would just update, see\nthat the \"major change\" was either affecting a component they weren't using at\nall, or was a tiny change, fixed it an moved on. It just wasn't a big deal.\n\nBut in open source, we cannot do breaking changes lightly,\n\nit has to be a marketing event really. We need announcement tweets and videos\nand blogposts and everything\n\nUsers hear about a new \"major\" version. Major sounds \"huge\", and \"good\", so the\nimmediate question is always:\n\nWhat are the new features?\n\nThe problem is: major versions are not about features. They are about breaking\nexisting APIs. Features mostly go in minors.\n\nRemember hooks? They came in 16.8. React Router added route loaders in 6.4, and\nbun added windows support in 1.1\n\nThat's because adding features rarely needs to break an existing API. Of course\nthere are exceptions, e.g. when you re-design something from the ground up that\nenables some new features. But usually, features come in minors.\n\nSo when I got asked about the new features in React Query v5, I started to\nsweat. We basically wanted to break a lot of APIs and rename things, and there\nweren't any features planned.\n\nSo we added some things that honestly, we could've also backported to v4. This\nis by no means great because we're withholding features from users just to have\nsome kind of \"marketing event\" and \"great new version\".\n\nIf it were up to me, I'd want a better system. Something where we decouple\n\"breaking changes\" from \"marketing events\". Anthony Fu had a great suggestion:\n\nto do 4-digit semver, so you can have an epoch number before major that you can\nuse for big overhauls or for marketing. I think it's a nice idea. I doubt it\nwill happen though - just something to think about.\n\nAnd maybe, when a new version comes out - don't think about what's new - ask\nwhat's breaking instead.\n\nOkay, So I'm no longer excited about major versions, but what I am still excited\nabout, even more than before I started with open source, is TYPESCRIPT.\n\nDon't worry - we're not gonna go into library level typescript today, but if\nyou're building something, I think it helps tremendously to think about types\nfrom the beginning and\n\ndesign your APIs with types in mind.\n\nNow there are lots of people who say that you should \"just make it work\" first\nand you can figure out the types later. I think they're wrong. When working with\nJavaScript, we can come up with all sorts of cute and dynamic constructs that\nwork at runtime, but are very hard to type.\n\nSure, almost everything is doable with enough magic, but usually, the price for\nthat is type complexity and maintenance burden.\n\nNot sure who said it, but this phrase stuck with me:\n\nIf something is hard for a compiler to figure out, it's also hard for humans to\nunderstand. So if we are having troubles expressing what we want to the\ncompiler, maybe the API we've chosen isn't the best.\n\nOne of the \"cute and dynamic\" constructs we had in React Query from when it\nstarted out (where it had no types), was was actually , because you could call\nit 3 different ways:\n\nwith different positional arguments. There's no good way to make this work in\nTypeScript except with overloads, which is what we did. Overloads are\nproblematic because they are a lot of overhead and error messages aren't good.\n\nTypeScript will try all overloads and then show an error for the last one it\ntried, which might be completely misleading. Also, we had to do some runtime\nchecks to transform different version into the same structure. And really, who\nneeds three ways to achieve the same thing?\n\nSo since v5, you can only call useQuery with the options syntax. With that, we\nreduced lines of types on useQuery by 80% - from 125 to just 25 lines of types.\n\nHad we started with types in mind from the beginning, I think this is where we\nwould've landed right away. Okay enough about TypeScript already, there's one\nthing that always comes up once a library reaches a certain threshold of usage:\n\nAnd to be honest, managing a demanding user base is one of the more tricky\nthings in open source. On the one hand, if you want to gain adoption, you need\nto listen to user feedback and meet their expectations, help them fix their\nproblems etc. On the other hand, the more you add to your library the more\nbloated the API becomes, adding complexity and thus reducing adoption again. We\nhave to balance this somehow.\n\nMy advice here would be to just take your time before adding anything. Users can\nbe very demanding, and in that relationship between user and maintainer, it's\ntheir job to tell you all about their use-case and how important it is for them\nand their deadlines\n\nBut it's the maintainer's job to have the bigger picture in mind. Will this work\nfor everybody? What about cases that the original requester hasn't considered\nbecause they don't even know about them‚Ä¶ Remember: once an API is added, we\ncan't change it without a new major release.\n\nAn example where I got this wrong was the refetchPage API for infinite queries.\nFor context, infinite queries are our way to make building doom-scrolling pages\nsimple - sorry about that. But technically, an infinite query is just one cache\nentry that is chunked up into multiple pages, where each page is built upon the\nprevious one.\n\nNow quite a lot of people complained that whenever a refetch occurs, React Query\nwould refetch all pages that are currently in the cache and wanted a way to only\nrefetch a single page, e.g. after updating a specific entry on that page.\n\nThis sounded reasonable at first, so we added a new field to some existing APIs\nlike invalidateQueries.\n\nNow, instead of refetching all pages, you could return false to have a specific\npage not refetch. That API was a mistake for a couple of reasons:\n\nThe API is weird and confusing. refetchPage now exists on invalidateQueries, but\ninvalidateQueries doesn't know about the type of a query. If there is a match\nfor tasks that is a non-infinite query, the param does nothing.\n\nWe only added this API to imperative methods because of technical constraints.\nIf an automatic refetch occurs that was triggered by React Query, you would\nstill refetch all pages.\n\nCorrectness is the main reason why we invalidate all pages per default. Each\npage builds upon the next like a linked-list. If you only refetch a page in the\nmiddle and one entry was deleted by someone else in the meantime, your UI can\nget weirdly out of sync.\n\nSo we took a step back and asked people that used it what their main motivation\nwas, and it was always the same: If the user scrolls down a lot, and I have 100\npages in the cache, I don't want to spam my server. That's fair, so we tried to\nfind an API that solves that problem instead. Eventually,\n\nwe settled on a new option on useInfiniteQuery - maxPages, which simply allows\nyou to limit how many pages you have in your cache.\n\nThis API is a lot better because it solves the problem holistically (from a\ndifferent point of view), for all kinds of refetches, and also speeds up\nrendering when you navigate to a page that has cached entries. We shipped in v5\nand removed refetchPages completely.\n\nMy takeaway here is that I landed on a suboptimal API decision too quickly, and\nhad I given myself more time to really understand the problem we're trying to\nsolve, I could've come up with something better.\n\nThe only alternative really is to ship new APIs with an unstable or experimental\nname, which can work but might lead to users not really wanting to use it. We\ndid this for some APIs, and these are the messages I get, so I'm not sure if\nthat's really better.\n\nAnother API that also gets requested often is to be able to debounce API calls.\nYou would want that for example when having a search field and you want to auto-\nfilter.\n\nUnless you want to fetch on every keystroke, you likely want some way of\ndebouncing that. This is a very good example for a feature that will not make it\ninto React Query because it's not its responsibility. There are a lot of ways to\ndo debouncing in different ways, and it likely needs more than just a number as\nan option. This can get complicated fast, and also adds more bundle size.\n\nThe good news is that you can relatively easily implement this in user-land\n\nYou can use your favourite implementation, write one yourself,\n\nor just from React. The way this works is that filter will contain the current\nuser input to display, and debouncedFilter has the debounced value that you pass\nto React Query.\n\nThis \"Inversion of Control\" is a great way to give users the flexibility to\nimplement features on their own and still keep a small API surface.\n\nNow the QueryKey is quite special here, but we can get inversion of control on\nother options as well by simply making them a function.\n\nOn example is a discussion I had with a user who felt that refetches on window\nfocus, which are turned on by default via refetchOnWindowFocus: true aren't\ngreat when the Query is in error state, which I agree might not be what you\nwant. But to add a separate option just for that case is not a great API. So\ninstead, what we did was make it accept a callback function:\n\nThe function always gets the query passed, and you can derive from that what you\nwant. That makes it very easy to implement that and similar feature in user-\nland. So by now, we've made almost all options accept callback functions. It's a\ncheap trick to allow users to implement certain behaviours for different states\nof the Query.\n\nOkay lastly, even if we keep all these points in mind, no matter how well we try\nto design an API, some people will be unhappy with it.\n\nAnd they will usually be the loudest. And open source maintainers are not immune\nto making errors, so chances are that eventually, we'll release an API that\nisn't well received. I learned that lesson the hard way in v4 of React Query,\nwhere we made some changes to our primary states.\n\nLet's take that search example from before again and see what happens if we\nhandle loading and error states in v4 with the derived boolean flags isLoading\nand isError.\n\nThis worked fine in v3, but in v4, it would just render a spinner for all\neternity.\n\nThat's because queries that start in a disabled state are also in \"isLoading\"\nstate. Now there are of course reasons for this, and it didn't sound as bad when\nI thought about it, but objectively, when you zoom out a bit and have no\nknowledge about React Query and you see this code and how it behaves - it's a\nvery bad API. Absolutely horrible, no excuses. Turns out, a lot of people felt\nthat way:\n\nAnd I agree - that's messed up. Btw, that counter is still going up even though\nwe've since fixed this in v5. But we got those reports right AFTER we had\nreleased the v4 major version. That feedback would've been very good a couple of\ndays earlier.\n\nWhat stuck with me is the user expectation that maintainers get everything right\nin their APIs while at the same time, the willingness to try out beta versions\nand report feedback is limited.\n\nSo if there's one thing that you take away from this talk, I want it to be this:\n\nPlease help out maintainers of open source libraries you are using by trying out\na beta version and report feedback. I guarantee you it's the best time to be\nheard.\n\nWithout that early feedback, mistakes might make it into the \"stable\" release.\nBut \"stable\" doesn't mean bug-free or battle-tested - it just means we can't\nchange our APIs anymore - it's now set in stone.\n\nOpen source is a two-way street, and this is one of the best ways to help while\nalso getting the most in return.\n\nThat's all I got, thank you üôè\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# React Query - The Bad Parts\nURL: https://tkdodo.eu/blog/react-query-the-bad-parts\n\n# React Query - The Bad Parts\n\n  * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * **#28: React Query - The Bad Parts**\n\n[ with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8274/0194f712-fae6-7a72-87f2-1b50b666d4a4/>)\n\nHere are the slides + transcript from the talk I recently gave at the\nconference. You can swipe left or right or use the arrow buttons / arrow keys to\nswitch between the slides. You can also find the recording on . Enjoy!\n\nThis is gonna be a quick one, almost a lightning talk really - because mostly,\n\n... React Query is just great ‚ù§Ô∏è. I think it's really loved by the community for\nproviding a great Developer Experience and User Experience alike. Now I know\nthat's a bold claim, but I have brought some data to back that up:\n\nIf we look at weekly download numbers on NPM, React Query has grown a lot this\nyear - from 4 million to almost 6 million - a 50% increase.\n\nNow those are huge numbers, but let's compare that to React ...\n\nwhich is also growing strong, sitting at 27M weekly downloads. Our curve doesn't\nlook as impressive anymore, but it also kinda implies that React Query is used\nin more than 20% of all React applications, or in every 5th app.\n\nAnd some of those apps ...\n\n... have millions of users themselves, like sentry, bsky or chatGPT, so React\nQuery really gets a lot of exposure.\n\nNow of course download numbers and usage aren't everything, just because\nsomething is used often doesn't necessarily mean it's liked.\n\nMaybe a better way is to look at surveys:\n\nState of frontend 2024 is quite new, and they asked \"which tools have you used\nto fetch data in the last year\"?\n\nI'm not gonna nit pick that RQ isn't a data fetching solution like axios or\nfetch, but behind those, it comes with a very high positive sentiment: Only 2.8%\nof people who used it didn't like it.\n\nState of React has a similar question around \"Utilities for loading and managing\ndata\", and if we group that by positive sentiment, TanStack Query actually comes\nout at the top with just over 44%.\n\nSo, I'm really happy that developers seem to like the library ...\n\n... because I've been maintaining it for the last 4 years.\n\nMy name is Dominik, I'm a Software Engineer living in Vienna, where I will be\njoining the Frontend Platform Team @ sentry next month. You can find me as\nTkDodo online almost everywhere, and I also have a blog where I write about\nReact and TypeScript, and of course, React Query.\n\nI've written and talked a lot about why React Query is great, and it really is,\nbut still:\n\neverything is a tradeoff. Using any piece of technology is usually a good\ntradeoff if the thing we are getting in return is better for us (worth more)\nthan what we are trading in.\n\nI think React Query is really a good tradeoff for most situations, but of course\nthere are cases where it might not be the best fit.\n\nSo today, I want to talk about these cases, but also debunk some myths I've\nheard about React Query that make it sound like it's bad when it probably isn't.\n\nSo maybe the talk is more like React Query - The Tradeoffs.\n\nSo let's get started with the first point, the elephant in the room -\n\nthe bundle-size. React Query has a huge bundle size is something I hear often as\nit's largest drawback.\n\nOkay let's first establish what the \"bundle size\" isn't:\n\nIt‚Äôs not what you see on npm. That‚Äôs the size that gets shipped when developers\ninstall the library. Yes, it's over 700kb, but we also ship codemods and all the\nsources and source-maps for you to better debug the lib if necessary. It's\ndefinitely NOT what gets shipped to the customer.\n\n...also not what you see on bundlephobia. It's a good site to get a quick\noverview, but it doesn't understand ESM properly (neither do I btw). We ship a\nspecial \"legacy\" build for older bundlers (üëã webpack 4) that isn‚Äôt as optimized,\nand that is what bundlephobia also picks up. (Any modern bundler like vite or\nwebpack 5 will see the more modern ESM build). So no, that size is also too\nlarge.\n\nSo where can we get the \"correct\" size then?\n\nI like bundlejs because it builds what we export on-the-fly with esbuild and\nshow its size impact.\n\nIf we export everything from React Query, we get to 12.4 kB minzipped. Now\nthat's not nothing, but it‚Äôs also not a lot. If we care about size, we should\nprobably use brotli compression instead of gzip -\n\nthat would get it down to 12 kb, nice.\n\nBut that is when we really use every single feature the library has to offer, so\nit isn't the typical starting point. You'll usually get quite far with just a ,\na , and .\n\nThat gets it to under 10kb - 9.63 kB to be exact.\n\nDon't get me wrong - bundle size is an important thing to look at before adding\na dependency.\n\nBut the debate about what is \"light-weight\" and what isn't is not the most\nimportant one when it comes to a central tool like your async state manager -\nEspecially because there's one metric that is easily left out - likely because\nit isn't easy to track:\n\nand that is bundle size you save by code you don't have to write\n\nA library like react-query \"pays for itself\" because the more you use it, the\nmore it saves you code that you would otherwise have to write yourself.\n\nSo when checking bundle size of a library, it's important to not only think\nabout the immediate size it adds, but also what it can save you in the long run.\nAnd on that scale, React Query is a clear and easy win for me. Most custom\nsolutions would likely be larger or would fail in edge case, because caching and\ncache invalidation is hard.\n\nThe next myth I would like to debunk is ...\n\nthe fact that React Query can't even fetch on a button click. I get that a lot.\nThe argument is that it's hard for React Query to do imperative data fetching.\nAnd it's true - React Query is declarative by default.\n\nWe define a QueryKey and a QueryFunction for useQuery, and it runs\nautomatically:\n\nThis code will try to read tasks from the cache, and if they don't exist, it\nwill go fetch and cache them for us. It will also do a background refetch if the\ndata is considered stale.\n\nSo far, so good. Now let‚Äôs try to add filtering to our Task List\n\nWe'll add a filter form that has an callback, and when that gets called, we‚Äôd\nwant to refetch the list with new filters:\n\nIf we explore what returns, we might find the method, and want to try passing\n...\n\n... filters directly to . Seems reasonable, except that doesn't accept any\narguments, so this won't work.\n\nI understand the frustration about this - but it's just not how React Query is\ndesigned to work. See, if we have a static key\n\nlike and we'd refetch with different arguments for that static key, we would not\nonly overwrite previously cached data, we would also run into race conditions\nthat you'd get with fetching in .\n\nReact Query has solved both of these problems with a declarative approach - by\nmaking your ...\n\n\"dependencies\" (what you use inside the QueryFunction) part of the QueryKey.\nThat means we have to store our somewhere, for example, in React State.\n\nWhen the applied filters change, the key changes and React Query will see a new\ncache entry and will get data for it, or read it from the cache.\n\nThis will get us from the imperative thinking: \"If I click this button, I want\nto refetch\" towards the declarative form of: \"I want data that matches this\nstate\". How it changes is irrelevant.\n\nIt's also irrelevant how / where we store the applied filters. With TanStack\nRouter...\n\nit's a pretty straight forward change to make a navigation with different search\nparams instead of storing it in React State:\n\nThis is of course type-safe depending on the search param schema defined on the\nroute, and now, we get a bunch of things for free, like sharable urls or browser\nback button navigation üéâ\n\nAnother cool thing is that if you change filters back to something you've\nalready fetched, you'll get an instant result. That's because React Query caches\neverything separately by its key. It's a simple document cache, which means the\ncomplete response will be stored under that key.\n\nSo yeah, in this example, if a task is both AND, it will be in both caches,\nbecause there is ...\n\n...no normalized caching in React Query. In a normalized cache, every piece of\ndata is stored once, and other parts only reference it, to avoid data\nduplication.\n\nDedicated solutions for GraphQL, like Apollo Client or urql, offer normalized\ncaching because they are aware of the schema and the relations between the\nentities.\n\nReact Query only knows Promises - it doesn't actually know what's inside the\ncache.\n\nIn the long feature comparison list from the docs page, Normalized Caching is\npretty much the only thing React Query flat out doesn't support. It's a pretty\nhard problem to solve and can add a lot of complexity, so the tradeoff we've\nchosen is to not support it. I think that for most applications, refetching upon\ninvalidation works well and is easier to understand too.\n\nSo yeah, if you're using GraphQL and need normalized caching, React Query might\nnot be the right choice for you.\n\nThere is however a community tool I want to highlight called. It tries to bring\nautomatic normalization and data updates to data fetching libraries, and it has\nintegrations for React Query, swr and rtk-query, so you might want to check that\nout if it sounds interesting to you.\n\nOkay, so we don't do normalized caching because we try to keep things simple,\nyet...\n\nI still hear that React Query is complex and has a steep learning curve.\n\nIf something is \"easy to understand\" for someone is always subjective - Things\nthat are straight-forward for you might be a total mystery to me.\n\nBut it's undeniable that React Query, like any concept worth applying, has a\nlearning curve, and it also has an API surface that isn't particularly small.\n\nI went into a lot of details about React Query's API design in my talk at the\nReact Advanced Conference earlier this year, so definitely check that one out if\nyou want an in-depth look at this topic.\n\nJust to touch on it - Tanner has a great tweet summarising the design-goals of\nReact Query, where he says that ...\n\n@Tan_Stack Query's API is actually medium sized when you unpack it all, but the\nmost important part is that you can understand and learn how to use it by\nstarting with a single function that provides 80% of the entire value\nproposition first try. From there, the rest of its API can be gradually learned\nif needed.\n\nSo while Query's API might seem overwhelming at first, you don't need to learn\neverything at once.\n\nYou can start with with the minimal required options, which will already give\nyou a ton of things:\n\nCaching, Request Deduplication, stale-while-revalidate background updates,\nglobal state management, automatic garbage collection, handling loading states,\nerror states + retries, the list goes on ...\n\nThen you might add a for performing updates and tying them to queries with query\ninvalidation; that's already a bit more code, but you can really get very far\nwith just those two ( and ).\n\nAnd as your app complexity grows, you might want to look deeper into what React\nQuery has to offer.\n\nMaybe you want to add an optimistic update, or an infinite query - those are\ncertainly a bit more involved.\n\nAnd all the way on the right side of the scale, we have our Persister Plugins\nand fine-grained direct cache subscriptions, which are really powerful &\nflexible. We e.g. use them to build our devtools.\n\nOnce you reach a certain application complexity, you are probably happy that\nthose exist, but ...\n\n...the Query API is absolutely designed to evolve with you.\n\nSo don't believe that it's necessary to learn everything from the start if that\nfeels overwhelming. Yes, there's a lot to learn, but you can get there\nincrementally.\n\nOkay so once you've learned the API and you're thinking that it's actually\ngreat...\n\n... you might want to start managing ALL your state with it. But since React\nQuery is bad...\n\nit really doesn't want you to do that. React Query is really designed to work\nwith async state - it's...\n\nan Async State manager that knows about the need of server state. It knows that\nthe data we're seeing is only a snapshot of the source of truth, which lives on\nthe server. It revalidates it and keeps what we see up-to-date, ...\n\nbecause it's also a data synchronization tool. It also makes assumptions about\nyour connectivity status and potentially retries getting that state.\n\nThis is what we love about React Query, but those are all things you don't need\nwhen you're storing something synchronous like a side-bar-state toggle....\n\nIF I had to write that with React Query, this is probably what it would look\nlike, which is far from ideal.\n\n1) come up with a unique key like that can't collide with anything else\n\n2) we don't actually need a because there is no async work to be done. We just\npass and update that with .\n\n3) and we need to turn of a bunch of configs to stop React Query from doing what\nit does best - managing and synchronizing async state.\n\nThis isn't easy to get right, it's verbose and it's not very efficient either.\n\nThe split in client state and server state is very much on purpose, because they\nhave different needs. So let's use the right tool for the right job. There are\nplenty of solutions available to manage client state, for example:\n\n- it's minimal, efficient and un-opinionated. We define a store with our state and actions to update that state. I've then created a custom hook to keep the same API as the previous implementation.\nA quite similar solution I also really like is\n\nbecause it works a bit better in TypeScript and is event driven.\n\nBut the thing is, there are no surprises with either one, they are both\nperfectly capable of efficiently managing that client state for us, so they are\ndefinitely better choices than using React Query for everything.\n\nOkay, so finally, the last thing I'm often hearing is quite funny: Why do I even\nneed a 3rd party library to do something as basic as data fetching - why\n\nwhy isn't this built into React?\n\nI can't really answer that because I don't work on React, but I've certainly\nfelt the frustration myself that we don't have a first class async primitive\nbuilt into React ...\n\nBut I think the reason could be that the React team really wants to get an API\nright before they ship it. As an example,\n\nwe're still wondering why they didn't ship context selectors - something that a\nlot of people have been requesting to get fine-grained subscriptions to a\ncontext.\n\nIn this example, we'd have a that contains a bunch of settings, but is only\ninterested in updates to the theme value, and should only re-render if color has\nchanged.\n\nThe change itself would probably not be hard to implement - but they aren't\ndoing it because the React team has a different vision - a place where ...\n\nwe can call the new operator inside , and React will bail out of rendering if we\nreturn the same values.\n\nNow this already composes a lot better than selectors, and eventually, this\nmight lead to a place where we can just write ...\n\nthat code without thanks to the React Compiler.\n\nThis is a great vision, but it takes time to get there (so this doesn't exist\nyet), and I think with data fetching, it's a similar story. Everyone \"just wants\nuseQuery\", but the React Team thinks bigger.\n\nSuspense is a beautiful architecture where your components get de-coupled from\nhandling loading and error states. It works so well with TypeScript too because\ndata can‚Äôt be .\n\nAnd of course, the vision goes beyond client-side data fetching.\n\nTo solve problems at a scale, React now spans to the server as well thanks to\nServer Components. I wish I had a quote but I couldn't find a good one from the\nReact team, so I'm just gonna say it:\n\nSuspense and Server Components ARE the async primitive we've been waiting for.\nAnd if you're able to work with a framework that supports Server Components,\nplease use them, and until then - .\n\nThat's al I got, thank you üôá‚Äç‚ôÇÔ∏è\n\nThat's it for today. Feel free to reach out to me on if you have any questions,\nor just leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#client-state-vs-server-state\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Develop and launch modern apps with MongoDB Atlas, a resilient data\nplatform.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8269/0194f713-0ab5-7483-a711-8c3744371908/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#react-query\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[**GenAI apps + MongoDB Atlas** You don't need a separate database to start\nbuilding GenAI-powered\napps.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8271/0194f713-29a0-7a62-a28f-a2311948ac32/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#the-defaults-explained\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Simplified data ingestion for\ndevelopers](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8326/0194f713-4a17-7013-9f1d-da445354d412/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#use-the-react-query-devtools\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[A better way for small teams to share an email inbox.**Give it a try for\nfree!**](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8333/0194f713-6730-7842-a460-93d80a703461/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#treat-the-query-key-like-a-dependency-array\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[video to see firsthand how to upgrade your site with end-to-end AI\nSearch.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8294/0194f713-8508-72c3-a7df-\ned1b1b9b08cc/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#a-new-cache-entry\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Transform docs into structured data with\nSensible.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8289/0194f713-a985-7b43-a942-516eb289228b/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#keep-server-and-client-state-separate\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Engineered with a suite of integrated services to let you build and deploy\nquickly.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8272/0194f713-ca83-72d0-99a8-5489a271716c/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * **#2: Putting props to useState**\nURL: https://tkdodo.eu/blog/putting-props-to-use-state\n\n* **#2: Putting props to useState**\n  * [#3: Things to know about useState](https://tkdodo.eu/blog/<things-to-know-about-use-state>)\n  * [#4: useState for one-time initializations](https://tkdodo.eu/blog/<use-state-for-one-time-initializations>)\n\n[A better way for small teams to share an email inbox.**Give it a try for\nfree!**](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8333/0194f713-f5ce-78a0-99af-560271f6aeaa/>)\n\nIn the of the useState pitfalls series, I talked about avoiding state all\ntogether for derived state.\n\nThis part is about a common scenario, where we want to initialize our state with\nvalues we get as props. This is something we probably do a lot, and it's not\nper-se wrong, but it has some potential issues that we need to be aware of.\n\nI will use a classic list / detail use-case as example. We have a list of\npersons, and selecting one of them will result in a detail form being filled. We\nwant to show the persons' email address in the detail form, and also have an\napply button that will update that data.\n\nIt's an interactive example, so feel free to click around (the code is also\neditable üöÄ):\n\nconst persons = [ { id: 1, name: 'Dominik', email: 'dominik@dorfmeister.cc', },\n{ id: 2, name: 'John', email: 'john@doe.com', }, ] function App() { const\n[selected, setSelected] = React.useState(persons[0]) return ( <div>\n{persons.map((person) => ( <button type=\"button\" key={person.id} onClick={() =>\nsetSelected(person)} > {person.id === selected.id ? person.name.toUpperCase() :\nperson.name} </button> ))} <DetailView initialEmail={selected.email} /> </div> )\n} function DetailView({ initialEmail }) { const [email, setEmail] =\nReact.useState(initialEmail) return ( <div> <input type=\"text\" value={email}\nonChange={(event) => setEmail(event.target.value)} /> <button type=\"button\"\nonClick={() => alert(email)}> Apply </button> </div> ) } render(<App />)\n\nYou might notice right away that the example is working. You can edit the email\naddress and click , but if you click on , the input field will not update.\n\nAs much as React wants us to rather than in lifecycles, when it comes to state,\nthere is a big difference between the first render (also known as ) and further\nrenders (better known as ).\n\nThe initial value of a useState hook is always on re-renders - it only has an\neffect when the component .\n\nWhen you click on , the DetailView component will be re-rendered (because it\nalready exists on the screen), which means that John's email will not be put\ninto our state. Bummer, because we still need the local state to edit the email\naddress (to keep the draft changes). We don't want to update the person Array\ndirectly, because we might never click Apply.\n\nI know three ways to handle this and similar use-cases:\n\n## 1. Conditionally render the DetailView\n\nWe do this a lot when we are using Modals or other components that appear on\nscreen.\n\nShowing the DetailView in a Modal will magically make our code above work,\nbecause Modals are usually rendered conditionally. When we click on , we mount a\nModal, thus the useState initial value will be respected. When the user closes\nthe Modal, it will be , and the next time a person is selected it will be again.\n\nHere is how that might look:\n\nconst persons = [ { id: 1, name: 'Dominik', email: 'dominik@dorfmeister.cc', },\n{ id: 2, name: 'John', email: 'john@doe.com', }, ] function App() { const\n[selected, setSelected] = React.useState() const close = () =>\nsetSelected(undefined) return ( <div> {persons.map((person) => ( <button\ntype=\"button\" key={person.id} onClick={() => setSelected(person)} >\n{person.name} </button> ))} {selected && ( <div style={{ position: 'fixed', top:\n'0', left: '0', paddingTop: '100px', width: '100%', height: '100%',\nbackgroundColor: 'rgba(0,0,0,0.4)', }} > <div style={{ display: 'flex',\njustifyContent: 'center', width: '80%', height: '50vh', margin: 'auto',\nbackgroundColor: 'white', }} > <DetailView initialEmail={selected.email}\nclose={close} /> <span style={{ cursor: 'pointer' }} onClick={close}> &times;\n</span> </div> </div> )} </div> ) } function DetailView({ initialEmail, close })\n{ const [email, setEmail] = React.useState(initialEmail) return ( <div> <input\ntype=\"text\" value={email} onChange={(event) => setEmail(event.target.value)} />\n<button type=\"button\" onClick={() => { alert(email) close() }} > Apply </button>\n</div> ) } render(<App />)\n\nExcuse my css, I suck at this part of web development üòÖ\n\nBut the example works now. That is because the Modal conditionally renders our\nDetailView, which will make it mount again.\n\nI'm sure many of you have done that a lot, and it's a valid solution. But be\naware that this only works because you are rendering the DetailView in the\nModal. If you want the DetailView to be renderable everywhere, we would need a\ndifferent solution.\n\nYou've probably heard this phrase before, the official React docs also have [a\nsection on that topic](https://tkdodo.eu/blog/<https:/reactjs.org/docs/lifting-\nstate-up.html>).\n\nFor this example, it basically just means to take the draft state and move it\nfurther up the tree, thus making our DetailView a fully controlled component.\nSince the DetailView then doesn't need any local state at all, we won't have the\nproblem of putting props into state.\n\nconst persons = [ { id: 1, name: 'Dominik', email: 'dominik@dorfmeister.cc', },\n{ id: 2, name: 'John', email: 'john@doe.com', }, ] function App() { const\n[selected, setSelected] = React.useState(persons[0]) const [email, setEmail] =\nReact.useState(selected.email) return ( <div> {persons.map((person) => ( <button\ntype=\"button\" key={person.id} onClick={() => { setSelected(person)\nsetEmail(person.email) }} > {person.id === selected.id ?\nperson.name.toUpperCase() : person.name} </button> ))} <DetailView email={email}\nsetEmail={setEmail} /> </div> ) } function DetailView({ email, setEmail }) {\nreturn ( <div> <input type=\"text\" value={email} onChange={(event) =>\nsetEmail(event.target.value)} /> <button type=\"button\" onClick={() =>\nalert(email)}> Apply </button> </div> ) } render(<App />)\n\nNow, the App has full control over all the state, and the DetailView is just a\nso-called \"dumb component\". This approach is feasible for many use-cases, but\nit's not without drawbacks.\n\nTyping in the input field will now re-render the whole App with every keystroke.\nWhile this is not a problem for this small example, it might be a problem for\nbigger Apps. People often resort to global state managers because they promise\nto re-render efficiently.\n\nOne could also argue that the scope of the draft email state is now too big. Why\ndoes the App even care about that, it probably only cares about the new email\nonce the user hits Apply.\n\nThe third approach is kind of the middle ground between the two: Keep the same\nux and the scope of the draft state small, but still re-mount your form when you\nneed to.\n\n## 3. Fully uncontrolled with a key\n\nconst persons = [ { id: 1, name: 'Dominik', email: 'dominik@dorfmeister.cc', },\n{ id: 2, name: 'John', email: 'john@doe.com', }, ] function App() { const\n[selected, setSelected] = React.useState(persons[0]) return ( <div>\n{persons.map((person) => ( <button type=\"button\" key={person.id} onClick={() =>\nsetSelected(person)} > {person.id === selected.id ? person.name.toUpperCase() :\nperson.name} </button> ))} <DetailView key={selected.id}\ninitialEmail={selected.email} /> </div> ) } function DetailView({ initialEmail\n}) { const [email, setEmail] = React.useState(initialEmail) return ( <div>\n<input type=\"text\" value={email} onChange={(event) =>\nsetEmail(event.target.value)} /> <button type=\"button\" onClick={() =>\nalert(email)}> Apply </button> </div> ) } render(<App />)\n\nThis is exactly the same code as in the first example, with just one small\nchange:\n\n```\n\n```\n\nThe attribute on a React component is a special thing. Keys are mostly used for\nlists to signalize stability to React, so that the reconciler knows which\nelements can be re-used, and thus re-rendered.\n\nHowever, you can also just put a key attribute on any component to tell React:\n\"Please mount this whenever the key changes. As long as the key is the same,\nplease re-render\".\n\nThis can be seen a little bit like the dependency array in effects. If it\nchanges, compared to the previous render, React will re-run the \"mounting\" of\nthe component.\n\nIf you want to know more, please read this .\n\nYou might be tempted to solve the problem with an effect that \"syncs\" props to\nstate:\n\n```\n\nCopysyncing-props-and-state: copy code to clipboard\n\n```\n\nI would consider effects like these generally an anti-pattern. If effects are\nused for syncing, they should be used to sync React state with something of\nReact, e.g. with localstorage.\n\nBut here, we are syncing something that already lives inside React with React\nstate. Further, the condition on which we sync does not really reflect what we\nwant to achieve: We want to reset the state whenever another person is selected,\nnecessarily when the email changes.\n\nThe first solution does this via conditional rendering, the second one by\nsetting the state explicitly when the button that selects a person is clicked,\nand the third one by providing a stable key (the selected persons' id).\n\nEmails might be a suboptimal example, because they are generally also unique,\nbut what if two persons have the same data (e.g. a firstName)? The effect won't\nre-run, even though we click on a different person, and thus the draft state is\nnot reset.\n\nSimilarly, what if the data changes in the parent component (e.g. because of a\nre-fetch by ), but our user has already changed the value in the input field?\nWould we really want to override the user input in these cases?\n\nSo, effects like these open you up to a bunch of hard-to-track errors in corner\ncases that you'd better avoid.\n\nPersonally, I don't have a preferred solution. I have used all three approaches\noccasionally.\n\nThe detail view owning the draft state has some advantages, but unmounting comes\nwith a bit of a cost, and you don't always have a stable key or a clear\nindication when a component should be reset.\n\nLifting state up also has advantages, as fully controlled components are usually\neasier to reason about, but it might not always be easily doable in large\napplications.\n\nWhatever you decide, please, don't use the syncing state \"solution\". To me, this\napproach is similar to the old lifecycle, which was also used to sync props with\nstate. I don't recall that ending well. is a very good article from 2018 by on\nthat anti-pattern, which also heavily inspired this article.\n\nWhich solution do you prefer? leave a comment below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#the-enabled-option-is-very-powerful\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[video to see firsthand how to upgrade your site with end-to-end AI\nSearch.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8294/0194f714-0dd0-7881-86ca-604cb29db057/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#dont-use-the-querycache-as-a-local-state-manager\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[No more spaghetti code. Build SMS solutions\nfast.](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8200/0194f714-3131-75d1-a715-ecd357f8e9ca/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n# * [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\nURL: https://tkdodo.eu/blog/practical-react-query#create-custom-hooks\n\n* [#2: React Query Data Transformations](https://tkdodo.eu/blog/<./react-query-data-transformations>)\n  * [#3: React Query Render Optimizations](https://tkdodo.eu/blog/<./react-query-render-optimizations>)\n  * [#4: Status Checks in React Query](https://tkdodo.eu/blog/<./status-checks-in-react-query>)\n  * [#6: React Query and TypeScript](https://tkdodo.eu/blog/<./react-query-and-type-script>)\n  * [#7: Using WebSockets with React Query](https://tkdodo.eu/blog/<./using-web-sockets-with-react-query>)\n  * [#8: Effective React Query Keys](https://tkdodo.eu/blog/<./effective-react-query-keys>)\n  * [#8a: Leveraging the Query Function Context](https://tkdodo.eu/blog/<./leveraging-the-query-function-context>)\n  * [#9: Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/<./placeholder-and-initial-data-in-react-query>)\n  * [#10: React Query as a State Manager](https://tkdodo.eu/blog/<./react-query-as-a-state-manager>)\n  * [#11: React Query Error Handling](https://tkdodo.eu/blog/<./react-query-error-handling>)\n  * [#12: Mastering Mutations in React Query](https://tkdodo.eu/blog/<./mastering-mutations-in-react-query>)\n  * [#14: React Query and Forms](https://tkdodo.eu/blog/<./react-query-and-forms>)\n  * [#16: React Query meets React Router](https://tkdodo.eu/blog/<./react-query-meets-react-router>)\n  * [#17: Seeding the Query Cache](https://tkdodo.eu/blog/<./seeding-the-query-cache>)\n  * [#20: You Might Not Need React Query](https://tkdodo.eu/blog/<./you-might-not-need-react-query>)\n  * [#21: Thinking in React Query](https://tkdodo.eu/blog/<./thinking-in-react-query>)\n  * [#22: React Query and React Context](https://tkdodo.eu/blog/<./react-query-and-react-context>)\n  * [#23: Why You Want React Query](https://tkdodo.eu/blog/<./why-you-want-react-query>)\n  * [#24: The Query Options API](https://tkdodo.eu/blog/<./the-query-options-api>)\n  * [#25: Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/<./automatic-query-invalidation-after-mutations>)\n  * [#26: How Infinite Queries work](https://tkdodo.eu/blog/<./how-infinite-queries-work>)\n  * [#27: React Query API Design - Lessons Learned](https://tkdodo.eu/blog/<./react-query-api-design-lessons-learned>)\n  * [#28: React Query - The Bad Parts](https://tkdodo.eu/blog/<./react-query-the-bad-parts>)\n\n[Simplified data ingestion for\ndevelopers](https://tkdodo.eu/blog/<https:/server.ethicalads.io/proxy/click/8327/0194f714-54b3-7443-b5f9-3a55cb27884b/>)\n\nWhen GraphQL and especially became popular in ca. 2018, there was a lot of fuss\nabout it completely replacing redux, and the question has been asked a lot.\n\nI distinctly remember not understanding what this was all about. Why would some\ndata fetching library replace your global state manager? What does one even have\nto do with the other?\n\nI was under the impression that GraphQL clients like Apollo would only fetch the\ndata for you, similar to what e.g. does for REST, and that you would still\nobviously need some way of making that data accessible to your application.\n\nI couldn't have been more wrong.\n\n## Client State vs. Server State\n\nWhat Apollo gives you is not just the ability to describe which data you want\nand to fetch that data, it also comes with a for that server data. This means\nthat you can just use the same hook in multiple components, and it will only\nfetch data once and then subsequently return it from the cache.\n\nThis sounds familiar with what we, and probably many other teams as well, have\nmainly been using for: Fetch data from the server and make it available\neverywhere.\n\nSo it seems that we have always been treating this like any other . Except that\nwhen it comes to (think: A list of articles that you fetch, the details of a\nUser you want to display, ...), your app does not own it. We have only borrowed\nit to display the most recent version of it on the screen for the user. It is\nthe server who owns the data.\n\nTo me, that introduced a paradigm shift in how to think about data. If we can\nleverage the cache to display data that we do not own, there isn't really much\nleft that is real client state that needs to be made available to the whole app.\nThat made me understand why many think that Apollo can replace redux in lots of\ninstances.\n\nI have never had the chance to use GraphQL. We have an existing REST API, don't\nreally experience problems with over-fetching, it just works, etc. Clearly,\nthere aren't enough pain points for us to warrant a switch, especially given\nthat you'd also have to adapt the backend, which isn't quite so simple.\n\nYet I still envied the simplicity of how data fetching can look like on the\nfrontend, including the handling of loading and error states. If only there were\nsomething similar in React for REST APIs...\n\nMade by the open sourcerer in late 2019, React Query takes the good parts of\nApollo and brings them to REST. It works with any function that returns a\nPromise and embraces the caching strategy. The library operates on sane defaults\nthat try to keep your data as fresh as possible while at the same time showing\ndata to the user as early as possible, making it feel near instant at times and\nthus providing a great UX. On top of that, it is also very flexible and lets you\ncustomize various settings for when the defaults are not enough.\n\nThis article is not going to be an introduction to React Query though.\n\nI think the docs are great at explaining Guides & Concepts, there are from\nvarious Talks that you can watch, and Tanner has a React Query you can take if\nyou want to get familiar with the library.\n\nI want to focus more on some practical tips that go beyond the docs, which might\nbe useful when you are already working with the library. These are things I have\npicked up over the last couple of months when I was not only actively using the\nlibrary at work, but also got involved in the React Query community, answering\nquestions on Discord and in GitHub Discussions.\n\nI believe the React Query are very well-chosen, but they can catch you off guard\nfrom time to time, especially at the beginning.\n\nFirst of all: React Query does invoke the on every re-render, even with the\ndefault of zero. Your app can re-render for various reasons at any time, so\nfetching every time would be insane!\n\n> Always code for re-renders, and a lot of them. I like to call it render\n> resiliency.\nIf you see a refetch that you are not expecting, it is likely because you just\nfocused the window and React Query is doing a , which is a great feature for\nproduction: If the user goes to a different browser tab, and then comes back to\nyour app, a background refetch will be triggered automatically, and data on the\nscreen will be updated if something has changed on the server in the meantime.\nAll of this happens without a loading spinner being shown, and your component\nwill not re-render if the data is the same as you currently have in the cache.\n\nDuring development, this will probably be triggered more frequently, especially\nbecause focusing between the Browser DevTools and your app will also cause a\nfetch, so be aware of that.\n\nSecondly, there seems to be a bit of confusion between and , so let me try to\nclear that up:\n\n  * : The duration until a query transitions from fresh to stale. As long as the query is fresh, data will always be read from the cache only - no network request will happen! If the query is stale (which per default is: instantly), you will still get data from the cache, but a background refetch can happen .\n  * : The duration until inactive queries will be removed from the cache. This defaults to 5 minutes. Queries transition to the inactive state as soon as there are no observers registered, so when all components which use that query have unmounted.\n\nMost of the time, if you want to change one of these settings, it's the that\nneeds adjusting. I have rarely ever needed to tamper with the . There is a good\nin the docs as well.\n\n### Use the React Query DevTools\n\nThis will help you immensely in understanding the state a query is in. The\nDevTools will also tell you what data is currently in the cache, so you'll have\nan easier time debugging. In addition to that, I have found that it helps to\nthrottle your network connection in the browser DevTools if you want to better\nrecognize background refetches, since dev-servers are usually pretty fast.\n\n### Treat the query key like a dependency array\n\nI am referring to the dependency array of the hook here, which I assume you are\nfamiliar with.\n\nWhy are these two similar?\n\nBecause React Query will trigger a refetch whenever the query key changes. So\nwhen we pass a variable parameter to our , we almost always want to fetch data\nwhen that value changes. Instead of orchestrating complex effects to manually\ntrigger a refetch, we can utilize the query key:\n\n```\n\nCopyfeature/todos/queries.ts: copy code to clipboard\n\n```\n\nHere, imagine that our UI displays a list of todos along with a filter option.\nWe would have some local state to store that filtering, and as soon as the user\nchanges their selection, we would update that local state, and React Query will\nautomatically trigger the refetch for us, because the query key changes. We are\nthus keeping the user's filter selection with the query function, which is very\nsimilar to what a dependency array represents for useEffect. I don't think I\nhave ever passed a variable to the that was part of the , too.\n\nBecause the query key is used as a key for the cache, you will get a new cache\nentry when you switch from 'all' to 'done', and that will result in a hard\nloading state (probably showing a loading spinner) when you switch for the first\ntime. This is certainly not ideal, so if possible, we can try to pre-fill the\nnewly created cache entry with . The above example is perfect for that, because\nwe can do some client side pre-filtering on our todos:\n\n```\n\nCopypre-filtering: copy code to clipboard\n\n```\n\nNow, every time the user switches between states, if we don't have data yet, we\ntry to show data from the 'all todos' cache. We can instantly show the 'done'\ntodos that we have to the user, and they will still see the updated list once\nthe background fetch finishes.\n\nI think this is a great ux improvement for just a few lines of code.\n\n### Keep server and client state separate\n\nThis goes hand in hand with , an article I have written last month: If you get\ndata from , try not to put that data into local state. The main reason is that\nyou implicitly opt out of all background updates that React Query does for you,\nbecause the state \"copy\" will not update with it.\n\nThis is fine if you want to e.g. fetch some default values for a Form, and\nrender your Form once you have data. Background updates are very unlikely to\nyield something new, and even if, your Form has already been initialized. So if\nyou do that on purpose, make sure to fire off unnecessary background refetches\nby setting :\n\n```\n\nCopyinitial-form-data: copy code to clipboard\n\n```\n\nThis concept will be a bit harder to follow through when you display data that\nyou also want to allow the user to edit, but it has many advantages. I have\nprepared a little codesandbox example:\n\nThe important part of this demo is that we never put the value that we get from\nReact Query into local state. This makes sure that we always see the latest\ndata, because there is no local \"copy\" of it.\n\n### The enabled option is very powerful\n\nThe hook has many options that you can pass in to customize its behaviour, and\nthe option is a very powerful one that you to do many cool things (pun\nintended). Here is a short list of things that we were able to accomplish thanks\nto this option:\n\n  * Fetch data in one query and have a second query only run once we have successfully obtained data from the first query.\n  * Turn queries on and off We have one query that polls data regularly thanks to , but we can temporarily pause it if a Modal is open to avoid updates in the back of the screen.\n  * Wait for user input Have some filter criteria in the query key, but disable it for as long as the user has not applied their filters.\n  * Disable a query after some user input e.g. if we then have a draft value that should take precedence over the server data. See the above example.\n\n### Don't use the queryCache as a local state manager\n\nIf you tamper with the queryCache (), it should only be for optimistic updates\nor for writing data that you receive from the backend after a mutation. Remember\nthat every background refetch might override that data, so for local state.\n\nEven if it's only for wrapping one call, creating a custom hook usually pays off\nbecause:\n\n  * You can keep the actual data fetching out of the ui, but co-located with your call.\n  * You can keep all usages of one query key (and potentially type definitions) in one file.\n  * If you need to tweak some settings or add some data transformation, you can do that in one place.\n\nYou have already seen an example of that in the .\n\nI hope that these practical tips will help you to get started with React Query,\nso go check it out :) If you have any further questions, please let me know in\nthe comments below. ‚¨áÔ∏è\n\nLike the monospace font in the code blocks?\n\n---\n\n",
  "metadata": {
    "wordCount": 75297,
    "charCount": 490131,
    "timestamp": "2025-02-11T22:17:06.004Z"
  }
}